<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIRECTION | Chemical Thinking</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,400;0,9..144,500;0,9..144,600;1,9..144,400;1,9..144,500&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --bg-tertiary: #1c2128;
            --text-primary: #E6EDF3;
            --text-secondary: #8B949E;
            --text-muted: #6e7681;
            --accent-blue: #58A6FF;
            --accent-coral: #F78166;
            --accent-green: #7EE787;
            --accent-purple: #a855f7;
            --border-subtle: rgba(255,255,255,0.08);
            --font-heading: 'Fraunces', Georgia, serif;
            --font-body: 'Inter', -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.75;
            font-size: 17px;
            -webkit-font-smoothing: antialiased;
        }

        /* ========== SCROLL PROGRESS ========== */
        .scroll-progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            z-index: 1000;
            width: 0%;
            transition: width 50ms linear;
        }

        /* ========== HERO ========== */
        .hero {
            min-height: 70vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 4rem 2rem;
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, rgba(88, 166, 255, 0.08) 0%, transparent 70%);
            pointer-events: none;
        }

        .hero-title {
            font-family: var(--font-heading);
            font-size: clamp(4rem, 12vw, 8rem);
            font-weight: 300;
            letter-spacing: 0.25em;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-subtitle {
            font-family: var(--font-heading);
            font-style: italic;
            font-size: 1.3rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .scroll-hint {
            position: absolute;
            bottom: 2rem;
            font-size: 1.5rem;
            color: var(--text-muted);
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-12px); }
            60% { transform: translateY(-6px); }
        }

        /* ========== MAIN CONTENT ========== */
        .content {
            max-width: 780px;
            margin: 0 auto;
            padding: 0 2rem 6rem;
        }

        /* ========== TYPOGRAPHY ========== */
        h2 {
            font-family: var(--font-heading);
            font-size: 2.2rem;
            font-weight: 400;
            margin: 5rem 0 2rem;
            color: var(--text-primary);
            letter-spacing: 0.02em;
        }

        h3 {
            font-family: var(--font-heading);
            font-size: 1.5rem;
            font-weight: 500;
            margin: 3.5rem 0 1.5rem;
            color: var(--text-primary);
        }

        h4 {
            font-family: var(--font-body);
            font-size: 1.1rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--accent-blue);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        p {
            margin-bottom: 1.5rem;
            color: var(--text-primary);
        }

        strong {
            color: var(--accent-blue);
            font-weight: 600;
        }

        em {
            font-style: italic;
            color: var(--text-primary);
        }

        /* ========== HORIZONTAL RULES ========== */
        hr {
            border: none;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border-subtle), transparent);
            margin: 4rem 0;
        }

        .section-break {
            text-align: center;
            margin: 4rem 0;
            color: var(--text-muted);
            font-size: 1.5rem;
            letter-spacing: 0.5em;
        }

        /* ========== DEFINITION POPUPS ========== */
        .def-popup {
            color: var(--accent-green);
            cursor: help;
            border-bottom: 1px dotted var(--accent-green);
            position: relative;
        }

        .def-popup:hover {
            color: #9ef0a0;
        }

        .def-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 1rem 1.25rem;
            width: 320px;
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-primary);
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
        }

        .def-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: var(--bg-tertiary);
        }

        .def-popup:hover .def-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* ========== LISTS ========== */
        ul, ol {
            margin: 1.5rem 0;
            padding-left: 1.5rem;
        }

        li {
            margin-bottom: 0.75rem;
        }

        li strong {
            color: var(--accent-coral);
        }

        /* ========== INTERACTIVE CONTAINERS ========== */
        .visual-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 2rem;
            margin: 3rem 0;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .visual-container.full-width {
            margin-left: -2rem;
            margin-right: -2rem;
            border-radius: 0;
            border-left: none;
            border-right: none;
        }

        .visual-label {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 1.5rem;
        }

        .visual-caption {
            font-size: 0.95rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 1.5rem;
            font-style: italic;
            max-width: 500px;
        }

        .visual-placeholder {
            width: 100%;
            height: 300px;
            background: linear-gradient(135deg, rgba(88,166,255,0.05), rgba(168,85,247,0.05));
            border: 2px dashed var(--border-subtle);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-family: var(--font-mono);
            font-size: 0.85rem;
        }

        /* ========== TABLES ========== */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            font-size: 0.95rem;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-subtle);
        }

        th {
            font-family: var(--font-heading);
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        td:first-child {
            color: var(--text-secondary);
            font-style: italic;
        }

        td:last-child {
            font-family: var(--font-mono);
            color: var(--accent-blue);
        }

        /* ========== DEFINITION BLOCK ========== */
        .definition-block {
            background: var(--bg-secondary);
            border-left: 3px solid var(--accent-blue);
            padding: 2rem;
            margin: 2.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .definition-block p {
            margin-bottom: 1.25rem;
        }

        .definition-block p:last-child {
            margin-bottom: 0;
        }

        .definition-block strong {
            color: var(--accent-coral);
        }

        /* ========== MATH ========== */
        .katex-display {
            margin: 1.5rem 0;
            overflow-x: auto;
        }

        .math-inline {
            font-family: var(--font-mono);
            color: var(--accent-blue);
        }

        /* ========== BLOCKQUOTES / PULLQUOTES ========== */
        blockquote {
            font-family: var(--font-heading);
            font-style: italic;
            font-size: 1.3rem;
            color: var(--accent-coral);
            border-left: 3px solid var(--accent-coral);
            padding-left: 1.5rem;
            margin: 2.5rem 0;
            line-height: 1.6;
        }

        /* ========== ENDNOTES ========== */
        .endnotes {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
        }

        .endnotes h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .endnote {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            padding-left: 2rem;
            position: relative;
        }

        .endnote-num {
            position: absolute;
            left: 0;
            color: var(--accent-blue);
            font-weight: 600;
        }

        sup a {
            color: var(--accent-blue);
            text-decoration: none;
            font-weight: 600;
        }

        sup a:hover {
            text-decoration: underline;
        }

        /* ========== FOOTER ========== */
        .page-footer {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
            font-size: 0.9rem;
            border-top: 1px solid var(--border-subtle);
        }

        .page-footer em {
            color: var(--text-secondary);
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 768px) {
            body {
                font-size: 16px;
            }

            .content {
                padding: 0 1.5rem 4rem;
            }

            h2 {
                font-size: 1.8rem;
            }

            h3 {
                font-size: 1.3rem;
            }

            .hero-title {
                letter-spacing: 0.15em;
            }

            .visual-container {
                padding: 1.5rem;
                margin: 2rem 0;
            }

            .def-tooltip {
                width: 260px;
                left: 0;
                transform: translateX(0);
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: 0.75rem;
            }
        }

        /* ========== SECTION VISIBILITY ========== */
        section {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* ========== PART HEADERS ========== */
        .part-header {
            text-align: center;
            margin: 6rem 0 4rem;
        }

        .part-number {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            color: var(--accent-purple);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 0.5rem;
        }

        .part-title {
            font-family: var(--font-heading);
            font-size: 1.8rem;
            font-weight: 400;
            color: var(--text-primary);
        }

        /* ========== PROLOGUE SPECIAL ========== */
        .prologue {
            text-align: center;
            max-width: 600px;
            margin: 0 auto 4rem;
        }

        .prologue p {
            font-size: 1.1rem;
            line-height: 1.9;
        }
    </style>
</head>
<body>
    <div class="scroll-progress" id="progress"></div>

    <!-- HERO -->
    <header class="hero">
        <h1 class="hero-title">DIRECTION</h1>
        <p class="hero-subtitle">The primitive of orientation. The sister of SAMENESS.</p>
        <div class="scroll-hint">↓</div>
    </header>

    <!-- MAIN CONTENT -->
    <main class="content">

        <!-- PROLOGUE -->
        <section class="prologue">
            <hr>
            <h2>Prologue: Two Sisters</h2>

            <p>SAMENESS and DIRECTION are twins born from the same mother.</p>

            <p><span class="def-popup" data-definition="Symmetry: An invariance under transformation. A system has symmetry with respect to operation T if applying T leaves the system unchanged. The collection of all such operations forms the symmetry group of the system.">Symmetry<span class="def-tooltip"></span></span> is what remains unchanged under transformation. Rotate a sphere — it looks identical. Translate empty space — indistinguishable from before. The persistence of form through change: this is SAMENESS.</p>

            <p><span class="def-popup" data-definition="Asymmetry: The absence of invariance under some transformation. A system has asymmetry when applying operation T produces a distinguishable result. Asymmetry breaks degeneracy and creates distinction.">Asymmetry<span class="def-tooltip"></span></span> is where invariance fails. Rotate a cone — you can tell. Translate toward a mass — the gravitational field changes. The failure of sameness under transformation creates distinction. Distinction in space is orientation. Orientation is DIRECTION.</p>

            <p><strong>Every direction exists because some symmetry is broken.</strong><br>
            <strong>Every symmetry persists because some direction is absent.</strong></p>

            <p>SAMENESS gives invariance. Asymmetry gives direction.</p>

            <p>The primitives require each other.</p>
        </section>

        <hr>

        <!-- PART I -->
        <div class="part-header">
            <div class="part-number">Part I</div>
            <div class="part-title">Symmetry, Asymmetry, and the Genesis of Direction</div>
        </div>

        <section>
            <h3>1.1 The Symmetric Void</h3>

            <p>Consider a state of perfect symmetry.</p>

            <p>An infinite homogeneous space. No matter. No fields. No gradients. Every point identical to every other point. Every direction equivalent to every other direction. The <span class="def-popup" data-definition="Isotropic: Having the same properties in all directions. An isotropic space or field shows no preferred orientation. Isotropy is rotational symmetry — invariance under arbitrary rotations about any point.">isotropic<span class="def-tooltip"></span></span> void.</p>

            <p>In this space, the question "which way?" has no answer. All ways are the same way. The concept of direction fails to gain traction because there is nothing to distinguish one orientation from another.</p>

            <p>This is the null case. Direction requires its negation.</p>
        </section>

        <!-- VISUAL: Isotropic Void -->
        <div class="visual-container" id="isotropic-void">
            <div class="visual-label">Visual: The Isotropic Void</div>
            <canvas id="isotropic-void-canvas" width="700" height="350"></canvas>
            <p class="visual-caption">Every point equivalent. Every direction the same. The question "which way?" has no answer.</p>
        </div>

        <section>
            <h3>1.2 The Breaking</h3>

            <p>Now introduce an asymmetry.</p>

            <p>Place a single massive body in the void. Instantly, the isotropy breaks. Every point in space now has a relationship to that mass — nearer or farther, attracted more or less. A <span class="def-popup" data-definition="Gradient: A vector field indicating the direction and rate of fastest increase of a scalar quantity. For a scalar field f, the gradient ∇f points in the direction where f increases most rapidly, with magnitude equal to that rate of increase.">gradient<span class="def-tooltip"></span></span> exists. And gradients have direction: toward the mass (down the potential) or away from it (up the potential).</p>

            <p>One object. One broken symmetry. Direction exists throughout the entire space.</p>

            <p>Or consider: rotate a perfect sphere, and nothing changes (symmetry preserved). Rotate a cone, and the change is detectable (symmetry broken). The cone has an axis. The cone points. The sphere does not.</p>

            <p><strong>The cone's direction exists because the cone lacks the rotational symmetry of the sphere.</strong></p>
        </section>

        <!-- VISUAL: The Breaking -->
        <div class="visual-container" id="symmetry-breaking-intro">
            <div class="visual-label">Visual: The Breaking</div>
            <canvas id="breaking-canvas" width="700" height="350"></canvas>
            <p class="visual-caption">Click to place a mass. Watch isotropy shatter. Direction emerges everywhere.</p>
        </div>

        <section>
            <h3>1.3 The Formal Structure</h3>

            <p>For direction to exist, three elements must coincide:</p>

            <h4>A. A state space</h4>
            <p>The set of possible configurations. Physical space. Phase space. The space of molecular conformations. The space of possible beliefs. Direction is always direction <em>in</em> something — a space that admits distinct positions.</p>

            <h4>B. An asymmetry</h4>
            <p>Something that distinguishes one region, axis, or trajectory from another. A gradient. A boundary condition. A shape with distinguishable ends. Without asymmetry, all orientations in the state space are equivalent, and "direction" becomes a distinction without a difference.</p>

            <h4>C. A structure that respects the asymmetry</h4>
            <p>Dynamics, geometry, or constraints that preserve and propagate the distinction. The asymmetry must have consequences — must matter to how the system behaves or how we describe it.</p>

            <p>When all three obtain, direction is present. Remove any one, and direction dissolves.</p>
        </section>

        <!-- VISUAL: Symmetry Breaking -->
        <div class="visual-container" id="symmetry-breaking">
            <div class="visual-label">Visual: Symmetry Breaking</div>
            <canvas id="sphere-cone-canvas" width="700" height="350"></canvas>
            <div class="morph-controls" style="margin-top: 1rem; display: flex; align-items: center; gap: 1rem; justify-content: center;">
                <span style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--text-muted);">SYMMETRY</span>
                <input type="range" id="morph-slider" min="0" max="100" value="0" style="width: 200px; accent-color: var(--accent-purple);">
                <span style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--text-muted);">DIRECTION</span>
            </div>
            <p class="visual-caption">As symmetry decreases, direction emerges. The shape itself begins to point.</p>
        </div>

        <section>
            <h3>1.4 The Taxonomy of Asymmetries</h3>

            <p>Different kinds of asymmetry generate different kinds of direction. The literature recognizes several families:<sup><a href="#fn1" id="ref1">1</a></sup></p>

            <p><strong>Geometric asymmetry → Spatial direction</strong><br>
            A cone points because its shape has a distinguished axis. A polar molecule has a direction because charge is distributed asymmetrically. The asymmetry is in the spatial structure of the object.</p>

            <p><strong>Thermodynamic asymmetry → Temporal direction</strong><br>
            The <span class="def-popup" data-definition="Arrow of time: The asymmetry between past and future directions in time. Typically grounded in the thermodynamic arrow (entropy was lower in the past), but philosophically distinct from the psychological arrow (we remember the past, not the future) and the cosmological arrow (the universe expands).">arrow of time<span class="def-tooltip"></span></span> points from past to future because entropy was lower in the past. The fundamental laws of physics are largely time-reversal symmetric; the direction of time emerges from asymmetric boundary conditions (the low-entropy early universe).<sup><a href="#fn2" id="ref2">2</a></sup></p>

            <p><strong>Interventionist asymmetry → Causal direction</strong><br>
            Causes precede effects. We can manipulate causes to change effects; we cannot manipulate effects to change causes. This asymmetry — which philosophers call the "arrow of causation" — grounds the directionality of causal relationships.<sup><a href="#fn3" id="ref3">3</a></sup></p>

            <p><strong>Gradient asymmetry → Field direction</strong><br>
            Wherever a scalar quantity varies across space, there is a gradient, and the gradient points in the direction of steepest increase. Concentration gradients. Temperature gradients. Electric potential gradients. The asymmetry is in the field values themselves.</p>

            <p><strong>Anatomical asymmetry → Bodily direction</strong><br>
            An organism with a front and a back has direction built into its morphology. Bilateral symmetry with a distinguished anterior end. The body's asymmetry generates a coordinate system: forward/backward, left/right, up/down (the last anchored to external gravity, not body structure).<sup><a href="#fn4" id="ref4">4</a></sup></p>

            <p><strong>Informational asymmetry → Intentional direction</strong><br>
            A system that represents a goal state and acts to reduce the difference between current and goal states exhibits directionality: toward the goal. This is the direction of purpose, of aim. The asymmetry lies in the system's internal model — it distinguishes where it wants to be from where it is.<sup><a href="#fn5" id="ref5">5</a></sup></p>

            <p>These categories share formal structure. In each case:</p>
            <ul>
                <li>A state space exists</li>
                <li>An asymmetry distinguishes one orientation from others</li>
                <li>The distinction has physical or behavioral consequences</li>
            </ul>
        </section>

        <hr>

        <!-- PART II -->
        <div class="part-header">
            <div class="part-number">Part II</div>
            <div class="part-title">Direction Before Formalization</div>
        </div>

        <section>
            <h3>2.1 The Organism's Direction</h3>

            <p>Long before mathematics, there was the amoeba.</p>

            <p>The amoeba moves through its environment. Toward nutrients. Away from toxins. No nervous system computes gradients. No representation of "direction" exists in the single cell. Directionality is present in the behavior: approach and avoidance.</p>

            <p>This is the <span class="def-popup" data-definition="Ur-direction: The most primitive form of directionality — the toward/away binary. Present in organisms without nervous systems (chemotaxis), in infant behavior (approach/avoidance), and as the cognitive foundation for more elaborated directional concepts.">ur-direction<span class="def-tooltip"></span></span>. The binary: toward and away. Approach and flee. Before angles, before degrees, before coordinate systems — there is this fundamental two-valued orientation.</p>

            <p>The mathematics of direction will give us continuous angles, unit vectors, dot products. These are refinements. The seed is binary: this way (toward) or that way (away).</p>
        </section>

        <!-- VISUAL: Ur-Direction -->
        <div class="visual-container" id="ur-direction">
            <div class="visual-label">Visual: The Ur-Direction</div>
            <canvas id="amoeba-canvas" width="700" height="400"></canvas>
            <p class="visual-caption">The first direction: toward what sustains, away from what destroys. Drag the nutrient or toxin.</p>
        </div>

        <section>
            <h3>2.2 Direction in the Body</h3>

            <p>The human body is asymmetric.</p>

            <p>You have a face. The face points forward — toward where you typically move, toward what you typically engage. The back of your head points away. This asymmetry is not arbitrary. Bilateral organisms that locomote develop anterior-posterior asymmetry because the front encounters the environment first. Eyes, mouth, sensory organs concentrate at the leading edge.</p>

            <p>From this single asymmetry — front versus back — a coordinate system unfolds:</p>

            <p><strong>Forward / Backward</strong>: Defined by the body's axis of locomotion, the direction the face points.</p>

            <p><strong>Left / Right</strong>: Perpendicular to forward, in the horizontal plane of the body. Defined by bilateral symmetry (or rather, by the bilateral symmetry's axis).</p>

            <p><strong>Up / Down</strong>: Perpendicular to the body's horizontal plane, aligned with gravity. This direction is anchored to the external world — up remains up even when you lie down.</p>

            <p>Six directions. Three pairs of opposites. Generated by two asymmetries: the body's front/back distinction (intrinsic) and gravity (extrinsic).</p>
        </section>

        <!-- VISUAL: Six Directions -->
        <div class="visual-container" id="body-directions">
            <div class="visual-label">Visual: The Six Directions</div>
            <canvas id="body-directions-canvas" width="700" height="400"></canvas>
            <div style="margin-top: 1rem; display: flex; align-items: center; gap: 1rem; justify-content: center;">
                <span style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--text-muted);">ROTATE BODY</span>
                <input type="range" id="body-rotation" min="0" max="360" value="0" style="width: 180px; accent-color: var(--accent-coral);">
            </div>
            <p class="visual-caption">Forward and back rotate WITH you. Up and down stay fixed by gravity. Asymmetry creates your coordinate system.</p>
        </div>

        <section>
            <h3>2.3 The Development of Directional Concepts</h3>

            <p>Developmental psychology tracks how children acquire directional concepts.<sup><a href="#fn6" id="ref6">6</a></sup></p>

            <p>The sequence is consistent across cultures:</p>

            <ol>
                <li><strong>Toward/Away</strong> — Present in infancy. Reaching toward, turning away. Preverbal and prereflective.</li>
                <li><strong>Forward/Backward</strong> — Emerges with locomotion. The crawling infant discovers that bodies have fronts.</li>
                <li><strong>Up/Down</strong> — Anchored in gravity, learned through falling and climbing. Universal and early.</li>
                <li><strong>Left/Right</strong> — Late and difficult. Children master forward/back by age 3-4 but struggle with left/right until 6-7. The distinction lacks external anchoring (unlike up/down with gravity). It is purely body-relative, and bodies rotate.</li>
            </ol>

            <p>The mathematical formalization of direction — vectors, angles, coordinates — comes much later, typically in adolescence. The perceptual and bodily understanding precedes the formal understanding by a decade or more.</p>

            <p><strong>This matters pedagogically.</strong> Students encountering vectors are not learning direction from scratch. They are formalizing something they have known, in a bodily sense, since infancy.</p>
        </section>

        <section>
            <h3>2.4 Direction Without Movement</h3>

            <p>A critical distinction: direction does not require motion.</p>

            <p>A weathervane points north even when the air is still. A signpost points toward the city while standing motionless. A bond between atoms points from one nucleus to the other in a frozen crystal.</p>

            <p>Direction is orientation in space. Motion is change of position over time. They are related — motion has a direction — but they are not identical. Static objects can have direction. A photograph of an arrow has direction. A sculpture facing east has direction.</p>

            <p>This matters for chemistry. We speak of the <em>direction</em> of a bond, the <em>direction</em> of a dipole moment, the <em>direction</em> of an orbital lobe. These are not moving. They are oriented. The language of direction applies to static structures.</p>
        </section>

        <hr>

        <!-- PART III -->
        <div class="part-header">
            <div class="part-number">Part III</div>
            <div class="part-title">The Geometry of Direction</div>
        </div>

        <section>
            <h3>3.1 The Circle of Directions (Two Dimensions)</h3>

            <p>Consider all possible directions in a plane.</p>

            <p>Between north and east lies northeast. Between north and northeast lies north-northeast. Between any two directions, another direction exists. Direction in two dimensions is continuous.</p>

            <p>What shape captures "all possible directions from a point"?</p>

            <p><strong>A circle.</strong></p>

            <p>Every point on a circle (centered at some origin) represents a direction: the direction from the origin to that point. The circle is not merely analogous to direction space; it <em>is</em> direction space in two dimensions. The set of all directions from a point in a plane is topologically identical to the circle S¹.</p>

            <p>A single number parameterizes position on the circle: the angle θ, measured from some reference direction (conventionally, the positive x-axis, counterclockwise). As θ varies from 0° to 360°, you traverse all possible directions, returning to where you started.</p>
        </section>

        <!-- VISUAL: Circle of Directions -->
        <div class="visual-container" id="circle-directions">
            <div class="visual-label">Visual: The Circle of Directions</div>
            <canvas id="circle-directions-canvas" width="700" height="350"></canvas>
            <p class="visual-caption">Drag anywhere on the circle. Every point is a direction. θ specifies which one.</p>
        </div>

        <section>
            <h3>3.2 The Sphere of Directions (Three Dimensions)</h3>

            <p>Extend to three dimensions.</p>

            <p>Now you can point up, down, and everywhere in between. The set of all directions from a point in three-dimensional space is a <span class="def-popup" data-definition="2-sphere (S²): The set of all points equidistant from a central point in three-dimensional space. Equivalently, the set of all unit vectors in ℝ³. Parameterized by two angles: azimuth (θ, 0° to 360°) and elevation (φ, -90° to +90° or 0° to 180°).">sphere<span class="def-tooltip"></span></span>.</p>

            <p>Every point on the surface of a sphere represents a direction: the direction from the center to that surface point. The sphere S² is direction space in three dimensions.</p>

            <p>Two angles parameterize position on the sphere:</p>
            <ul>
                <li><strong>Azimuth (θ)</strong>: The compass direction — the angle in the horizontal plane.</li>
                <li><strong>Elevation (φ)</strong>: The angle above or below the horizon.</li>
            </ul>

            <p>As θ and φ vary over their full ranges, every possible direction in 3D space is covered.</p>

            <p>This is what the owl's head does when it swivels. The owl samples the sphere of directions, selecting one for its gaze. The mathematics of spherical coordinates describes this sampling.</p>
        </section>

        <!-- VISUAL: Sphere of Directions -->
        <div class="visual-container" id="sphere-directions">
            <div class="visual-label">Visual: The Sphere of Directions</div>
            <canvas id="sphere-directions-canvas" width="700" height="400"></canvas>
            <div style="display: flex; gap: 2rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary);">
                    <span style="font-family: var(--font-mono); min-width: 100px;">θ (azimuth)</span>
                    <input type="range" id="sphere-azimuth" min="0" max="360" value="45" style="width: 140px;">
                    <span id="sphere-azimuth-val" style="font-family: var(--font-mono); min-width: 45px;">45°</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary);">
                    <span style="font-family: var(--font-mono); min-width: 100px;">φ (elevation)</span>
                    <input type="range" id="sphere-elevation" min="-90" max="90" value="30" style="width: 140px;">
                    <span id="sphere-elevation-val" style="font-family: var(--font-mono); min-width: 45px;">30°</span>
                </label>
            </div>
            <p class="visual-caption">In three dimensions, direction space is a sphere. Two angles specify any direction.</p>
        </div>

        <section>
            <h3>3.3 Direction as Relation</h3>

            <p>Direction is a relation between points.</p>

            <p>"The library is north" — north of <em>what</em>? The library has no intrinsic northness. The statement requires a reference: the library is north <em>of here</em>.</p>

            <p>"The bond points toward the oxygen" — from <em>where</em>? From the carbon.</p>

            <p>Every direction has an origin. Every arrow has a tail. This reflects the relational nature of direction itself. Direction is a binary relation: from A, toward B.</p>

            <p>The <span class="def-popup" data-definition="Vector: A mathematical object with both magnitude and direction. Formally, an element of a vector space. Geometrically, represented as an arrow with a tail (origin) and head (terminus), encoding direction and length.">vector<span class="def-tooltip"></span></span>, when we formalize it, will have two pieces: a starting point and an ending point, or equivalently, an origin and a displacement. The structure of the formalism mirrors the structure of direction as relation.</p>
        </section>

        <section>
            <h3>3.4 Comparing Directions</h3>

            <p>Given two directions, how similar are they?</p>

            <p>At the extremes:</p>
            <ul>
                <li><strong>Same direction</strong>: The two directions are identical. Perfect alignment.</li>
                <li><strong>Opposite directions</strong>: The two directions differ by 180°. Perfect opposition.</li>
                <li><strong>Perpendicular directions</strong>: The two directions differ by 90°. Complete independence.</li>
            </ul>

            <p>Between these: partial alignment, partial opposition.</p>

            <p>A question arises: <em>How much</em> of direction A is "in" direction B? If B is close to A, most of A is captured by B. If B is perpendicular to A, none of A is captured. If B is opposite to A, the relationship is maximally negative.</p>

            <p>This question — quantifying the alignment of two directions — leads to the <span class="def-popup" data-definition="Dot product (inner product): An operation on two vectors yielding a scalar. For vectors a and b, the dot product a·b = |a||b|cos(θ), where θ is the angle between them. Positive when aligned, zero when perpendicular, negative when opposed.">dot product<span class="def-tooltip"></span></span>. The dot product measures the extent to which two directions agree.</p>

            <p>The <em>question</em> precedes the <em>tool</em>. You can feel that northeast is "more north than east." The dot product is notation for that intuition.</p>
        </section>

        <!-- VISUAL: Comparing Directions -->
        <div class="visual-container" id="comparing-directions">
            <div class="visual-label">Visual: Comparing Directions</div>
            <canvas id="comparing-directions-canvas" width="700" height="350"></canvas>
            <p class="visual-caption">Drag either arrow. The angle between them measures alignment.</p>
        </div>

        <section>
            <h3>3.5 Magnitude and Direction</h3>

            <p>Some directed quantities have intensity.</p>

            <p>The wind blows east. How strongly? A breeze or a gale — both east, different magnitudes.</p>

            <p>The ground slopes downward. How steeply? A gentle incline or a cliff — both down, different magnitudes.</p>

            <p><strong>Direction</strong> specifies orientation. <strong>Magnitude</strong> specifies intensity. The combination is ubiquitous: velocity, force, acceleration, electric field, dipole moment.</p>

            <p>A <strong>vector</strong> packages both: direction (which way) and magnitude (how much). Graphically, an arrow of specified length pointing in a specified direction.</p>

            <p>Direction and magnitude are separable:</p>
            <ul>
                <li><strong>Pure direction</strong> (no magnitude): a compass heading, a unit vector, an orientation.</li>
                <li><strong>Pure magnitude</strong> (no direction): temperature, mass, concentration — scalars.</li>
                <li><strong>Both</strong>: vectors.</li>
            </ul>

            <p>The vector is the formalization of the primitive. Direction came first, in perception and behavior. The vector notation came later, to enable calculation.</p>
        </section>

        <!-- VISUAL: Direction vs Magnitude -->
        <div class="visual-container" id="magnitude-direction">
            <div class="visual-label">Visual: Direction vs. Magnitude</div>
            <canvas id="magnitude-direction-canvas" width="700" height="320"></canvas>
            <div style="display: flex; gap: 2rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary);">
                    <span style="font-family: var(--font-mono);">Direction θ</span>
                    <input type="range" id="mag-dir-angle" min="0" max="360" value="45" style="width: 120px;">
                    <span id="mag-dir-angle-val" style="font-family: var(--font-mono); min-width: 40px;">45°</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-secondary);">
                    <span style="font-family: var(--font-mono);">Magnitude |v|</span>
                    <input type="range" id="mag-dir-length" min="20" max="100" value="60" style="width: 120px;">
                    <span id="mag-dir-length-val" style="font-family: var(--font-mono); min-width: 40px;">60</span>
                </label>
            </div>
            <p class="visual-caption">Direction answers "which way?" Magnitude answers "how much?" Vectors answer both.</p>
        </div>

        <hr>

        <!-- PART IV -->
        <div class="part-header">
            <div class="part-number">Part IV</div>
            <div class="part-title">Direction in Physical Systems</div>
        </div>

        <section>
            <h3>4.1 Gradients: Direction from Landscape</h3>

            <p>Consider a scalar field — a quantity that varies across space. Temperature in a room. Concentration in a solution. Electric potential around a charge. Elevation on terrain.</p>

            <p>At any point, some directions lead to higher values, others to lower values. One direction is special: the direction of steepest ascent — the way that increases the value most rapidly. This is the <strong>gradient</strong>.</p>

            <p>Formally, for a scalar field f(x,y,z), the gradient ∇f is a vector field pointing in the direction of greatest increase of f at each point. The magnitude of the gradient equals the rate of that increase.</p>

            <p>Physical systems respond to gradients:</p>
            <ul>
                <li><strong>Thermal diffusion</strong>: Heat flows down the temperature gradient (from hot to cold).</li>
                <li><strong>Molecular diffusion</strong>: Particles flow down the concentration gradient (from high to low concentration).</li>
                <li><strong>Electrostatics</strong>: Positive charges move down the electric potential gradient.</li>
                <li><strong>Gravity</strong>: Objects move down the gravitational potential gradient.</li>
            </ul>

            <p>In each case, "down" means "opposite to the gradient direction." Systems evolve toward lower values of the relevant potential. The gradient specifies "uphill."</p>
        </section>

        <!-- VISUAL: Gradient Landscape -->
        <div class="visual-container" id="gradient-landscape">
            <div class="visual-label">Visual: The Gradient Landscape</div>
            <canvas id="gradient-landscape-canvas" width="700" height="400"></canvas>
            <p class="visual-caption">Click anywhere. The gradient arrow points uphill. The ball rolls downhill.</p>
        </div>

        <section>
            <h3>4.2 Causation: The Direction of Influence</h3>

            <p>A causes B.</p>

            <p>This statement has direction. A comes before B (in time). Manipulating A changes B; manipulating B does not change A. The relationship is asymmetric.</p>

            <p>The arrow of causation points from cause to effect. The asymmetry is grounded in the structure of time and intervention. We can wiggle causes experimentally and observe effects change. We cannot wiggle effects and observe causes change.</p>

            <p>In chemistry, reaction mechanisms are chains of causal arrows:</p>

            <p style="text-align: center; font-family: var(--font-mono); color: var(--accent-blue); font-size: 1.1rem; margin: 2rem 0;">
                Nucleophile → Electrophile → Transition State → Product
            </p>

            <p>Each arrow represents "leads to" — a directional relationship in the space of molecular events. The mechanism has a direction: from reactants toward products.</p>

            <p>This is direction in a non-spatial sense. The "space" is the space of chemical transformations. The "direction" is the trajectory from earlier states to later states.</p>
        </section>

        <!-- VISUAL: Causation -->
        <div class="visual-container" id="causation-flow">
            <div class="visual-label">Visual: The Arrow of Causation</div>
            <canvas id="causation-flow-canvas" width="700" height="350"></canvas>
            <p class="visual-caption">Causation has direction. Time has direction. Mechanism arrows trace causal flow.</p>
        </div>

        <section>
            <h3>4.3 Direction in Molecular Structure</h3>

            <p>A covalent bond has direction. It extends from one nucleus to another.</p>

            <p>When bonded atoms differ in electronegativity, the bond has a <strong>dipole moment</strong> — a vector pointing from partial positive toward partial negative. The dipole moment encodes both magnitude of charge separation and direction of that separation.</p>

            <p>Molecular geometry is a collection of bond directions. Water: two O-H bonds at 104.5°. Ammonia: three N-H bonds in pyramidal arrangement. Methane: four C-H bonds in tetrahedral directions. The shape of a molecule is a set of directions from a central point.</p>

            <p>Atomic orbitals have direction. The three p orbitals — p<sub>x</sub>, p<sub>y</sub>, p<sub>z</sub> — are identical in shape but point along different axes. The d orbitals have more complex orientations. Hybridization theory combines these to predict bond directions.</p>

            <p>VSEPR theory predicts molecular geometry by assuming electron domains repel and arrange to maximize angular separation — to spread as far apart as possible on the sphere of directions around a central atom.</p>

            <p><strong>Direction is not peripheral to chemistry. Direction <em>is</em> molecular structure.</strong></p>
        </section>

        <section>
            <h3>4.4 Vector Fields</h3>

            <p>A <strong>vector field</strong> assigns a direction (with magnitude) to every point in a region.</p>

            <p>The gravitational field around Earth: at every point, a vector pointing toward Earth's center.</p>

            <p>The electric field around a charge: at every point, a vector pointing away from positive charge (or toward negative).</p>

            <p>The velocity field in a flowing fluid: at every point, a vector indicating direction and speed of flow.</p>

            <p>Fields make direction systematic — direction everywhere, simultaneously. Vector calculus (divergence, curl, line integrals) describes how direction varies across space, how it flows, how it accumulates.</p>
        </section>

        <hr>

        <!-- PART V -->
        <div class="part-header">
            <div class="part-number">Part V</div>
            <div class="part-title">The Formalism</div>
        </div>

        <section>
            <h3>5.1 Why Formalize?</h3>

            <p>You already understand direction. What does mathematical formalism add?</p>

            <p><strong>Precision</strong>: You can point at the library and say "over there." Formalism lets you say "bearing 047°, distance 2.3 km" — a specification reproducible by anyone with a map and compass.</p>

            <p><strong>Calculation</strong>: You can sense the hill is steeper this way. Formalism lets you compute the exact slope, predict where a ball will roll, design a road with acceptable grade.</p>

            <p><strong>Communication</strong>: Bodily direction knowledge is private. Formalized direction can be written, transmitted, stored, shared.</p>

            <p><strong>Generalization</strong>: Physical intuitions are anchored in three spatial dimensions. Formalism generalizes to any number of dimensions — essential for thermodynamics (high-dimensional state spaces), quantum mechanics (infinite-dimensional Hilbert spaces), and data science (hundreds of features).</p>

            <p>The formalism extends intuition's reach.</p>
        </section>

        <section>
            <h3>5.2 The Bridge</h3>

            <table>
                <thead>
                    <tr>
                        <th>Perception</th>
                        <th>Formal Tool</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>"It points somewhere"</td>
                        <td>Vector</td>
                    </tr>
                    <tr>
                        <td>"How aligned are these two directions?"</td>
                        <td>Dot product</td>
                    </tr>
                    <tr>
                        <td>"What's perpendicular to both?"</td>
                        <td>Cross product</td>
                    </tr>
                    <tr>
                        <td>"Which way is steepest?"</td>
                        <td>Gradient</td>
                    </tr>
                    <tr>
                        <td>"Describe this direction exactly"</td>
                        <td>Components</td>
                    </tr>
                </tbody>
            </table>

            <p>Each tool formalizes a question you already know how to ask.</p>
        </section>

        <!-- VISUAL: The Bridge -->
        <div class="visual-container" id="bridge-animation">
            <div class="visual-label">Visual: The Bridge</div>
            <canvas id="bridge-animation-canvas" width="700" height="380"></canvas>
            <p class="visual-caption">The perception came first. The mathematics is notation for what you already see.</p>
        </div>

        <section>
            <h3>5.3 Formal Definitions</h3>

            <p>These definitions are for reference. Terms appear throughout with popup definitions on hover.</p>

            <div class="definition-block">
                <p><strong>Vector</strong>: An element of a vector space; a quantity with magnitude and direction. In ℝ³, represented as <strong>v</strong> = (v₁, v₂, v₃). Magnitude: |<strong>v</strong>| = √(v₁² + v₂² + v₃²).</p>

                <p><strong>Unit vector</strong>: A vector of magnitude 1. For nonzero <strong>v</strong>, the unit vector is <strong>v̂</strong> = <strong>v</strong>/|<strong>v</strong>|. Unit vectors encode pure direction.</p>

                <p><strong>Dot product</strong>: For <strong>a</strong> = (a₁, a₂, a₃) and <strong>b</strong> = (b₁, b₂, b₃):<br>
                <span style="font-family: var(--font-mono); color: var(--accent-blue);">a · b = a₁b₁ + a₂b₂ + a₃b₃ = |a||b|cos(θ)</span><br>
                Measures alignment. Positive when aligned, zero when perpendicular, negative when opposed.</p>

                <p><strong>Cross product</strong>: For <strong>a</strong> and <strong>b</strong> in ℝ³:<br>
                <span style="font-family: var(--font-mono); color: var(--accent-blue);">a × b = (a₂b₃ - a₃b₂, a₃b₁ - a₁b₃, a₁b₂ - a₂b₁)</span><br>
                Yields a vector perpendicular to both, with magnitude |<strong>a</strong>||<strong>b</strong>|sin(θ).</p>

                <p><strong>Gradient</strong>: For scalar f(x, y, z):<br>
                <span style="font-family: var(--font-mono); color: var(--accent-blue);">∇f = (∂f/∂x, ∂f/∂y, ∂f/∂z)</span><br>
                Points toward steepest increase.</p>

                <p><strong>Basis</strong>: A set of vectors {<strong>e</strong>₁, <strong>e</strong>₂, ..., <strong>e</strong>ₙ} spanning the space. Standard basis in ℝ³: <strong>î</strong> = (1,0,0), <strong>ĵ</strong> = (0,1,0), <strong>k̂</strong> = (0,0,1).</p>

                <p><strong>Components</strong>: Coefficients in a basis expansion. For <strong>v</strong> = v₁<strong>î</strong> + v₂<strong>ĵ</strong> + v₃<strong>k̂</strong>, components are (v₁, v₂, v₃).</p>
            </div>
        </section>

        <hr>

        <!-- PART VI -->
        <div class="part-header">
            <div class="part-number">Part VI</div>
            <div class="part-title">SAMENESS and DIRECTION as Duals</div>
        </div>

        <section>
            <h3>6.1 The Symmetry-Asymmetry Duality</h3>

            <p>SAMENESS detects what is preserved under transformation.<br>
            DIRECTION detects what is distinguished by transformation.</p>

            <p>These are dual perspectives on the same structure.</p>

            <p>Consider rotation. A sphere is unchanged by any rotation about its center — full rotational symmetry. SAMENESS is maximal. A cone is changed by most rotations — only rotations about its axis preserve it. Partial symmetry. DIRECTION (the axis) emerges where symmetry is broken.</p>

            <p><strong>The more symmetry a system has, the less direction it can support.<br>
            The more direction a system exhibits, the less symmetry it can have.</strong></p>
        </section>

        <section>
            <h3>6.2 Symmetry Operations Define Equivalence of Directions</h3>

            <p>The symmetry operations of a system — the transformations leaving it unchanged — define which directions are equivalent.</p>

            <p>A crystal with cubic symmetry has no preferred direction along any cube diagonal or face normal. They are all equivalent by symmetry. Introduce a defect that breaks cubic symmetry, and those directions become distinguishable.</p>

            <p><span class="def-popup" data-definition="Group theory: The mathematical study of symmetry. A group is a set of operations closed under composition, with an identity element and inverses. The symmetry group of a system contains all transformations leaving the system invariant.">Group theory<span class="def-tooltip"></span></span>, the mathematics of symmetry, implicitly describes direction. The symmetry group specifies which directions are equivalent. Everything outside that equivalence is where direction gains traction.</p>
        </section>

        <section>
            <h3>6.3 Chemistry Applications</h3>

            <p>Symmetry and direction interact throughout chemistry:</p>

            <p><strong>Molecular symmetry</strong> (SAMENESS): Does the molecule have a plane of symmetry? An inversion center? A rotation axis? Point groups classify molecular symmetry. Spectroscopy, polarity, chirality depend on these symmetries.</p>

            <p><strong>Dipole moments</strong> (DIRECTION): A molecule has a net dipole moment if and only if its charge distribution is asymmetric — if symmetry is insufficient to cancel bond dipoles. The presence or absence of certain symmetry elements determines whether direction emerges.</p>

            <p><strong>Selection rules</strong>: Spectroscopic transitions are allowed or forbidden based on symmetry. The electric field of light has direction; it drives only transitions with appropriate symmetry relationship to that direction.</p>

            <p><strong>Stereochemistry</strong>: Which face of a molecule is attacked? Which configuration results? Direction in reactions is constrained by symmetry of reactants, catalysts, and transition states.</p>

            <p>The sister primitives work together.</p>
        </section>

        <hr>

        <!-- PART VII -->
        <div class="part-header">
            <div class="part-number">Part VII</div>
            <div class="part-title">Summary</div>
        </div>

        <section>
            <h3>7.1 What Direction Is</h3>

            <p>Direction is orientation in a state space, made possible by asymmetry.</p>

            <p>In symmetric situations, no direction is preferred; all orientations are equivalent. Asymmetry — in geometry, in boundary conditions, in dynamics — breaks equivalence and creates distinction. That distinction is direction.</p>

            <p>The perception of direction precedes its formalization. Infants reach toward; amoebas chemotax; humans point and face. The body generates directional experience through its own asymmetries (front/back) and its relationship to external asymmetries (gravity).</p>

            <p>The formalism — vectors, dot products, gradients — captures this perception in notation. The tools enable precision, calculation, and communication. They serve the perception; they do not replace it.</p>
        </section>

        <section>
            <h3>7.2 Forward</h3>

            <p>We take DIRECTION into chemistry:</p>

            <p><strong>Lecture 4: Bonds Point</strong> — The bond as a vector. Molecular geometry as a collection of directions.</p>

            <p><strong>Lecture 5: Angles and Projections</strong> — The dot product as a tool for comparing bond directions. Bond angles.</p>

            <p><strong>Lecture 6: Coordinates</strong> — Basis vectors and components. Representing molecular structures.</p>

            <p>The primitive is established. Now we apply it.</p>
        </section>

        <!-- ENDNOTES -->
        <div class="endnotes">
            <h2>Endnotes</h2>

            <div class="endnote" id="fn1">
                <span class="endnote-num">[1]</span>
                For a comprehensive treatment of symmetry breaking and direction, see the Stanford Encyclopedia of Philosophy entry "Symmetry and Symmetry Breaking" (Brading & Castellani, 2003) and "Thermodynamic Asymmetry in Time" (North, 2011). <a href="#ref1">↩</a>
            </div>

            <div class="endnote" id="fn2">
                <span class="endnote-num">[2]</span>
                The thermodynamic arrow of time is analyzed in Price (1996), <em>Time's Arrow and Archimedes' Point</em>, and Albert (2000), <em>Time and Chance</em>. The puzzle: microscopic laws are time-symmetric; macroscopic directionality emerges from low-entropy boundary conditions. <a href="#ref2">↩</a>
            </div>

            <div class="endnote" id="fn3">
                <span class="endnote-num">[3]</span>
                The interventionist account of causation is developed in Woodward (2003), <em>Making Things Happen</em>, and Pearl (2000), <em>Causality</em>. Causal direction reflects the asymmetry of intervention: earlier variables can be manipulated to change later ones, not vice versa. <a href="#ref3">↩</a>
            </div>

            <div class="endnote" id="fn4">
                <span class="endnote-num">[4]</span>
                Anatomical asymmetry and its developmental origins are discussed in Palmer (2004), "Symmetry Breaking and the Evolution of Development" (<em>Science</em> 306:828-833), and Levin (2005), "Left-right asymmetry in embryonic development" (<em>Annual Review of Cell and Developmental Biology</em> 21:319-345). <a href="#ref4">↩</a>
            </div>

            <div class="endnote" id="fn5">
                <span class="endnote-num">[5]</span>
                Teleonomic direction and goal-directed systems are analyzed in Corning (2014), "Systems Theory and the Role of Synergy in the Evolution of Living Systems" (<em>Systems Research and Behavioral Science</em> 31:523-542). <a href="#ref5">↩</a>
            </div>

            <div class="endnote" id="fn6">
                <span class="endnote-num">[6]</span>
                The developmental sequence of spatial concepts is reviewed in Newcombe & Huttenlocher (2000), <em>Making Space: The Development of Spatial Representation and Reasoning</em>. The difficulty of left/right reflects its lack of external anchoring. <a href="#ref6">↩</a>
            </div>
        </div>

    </main>

    <!-- FOOTER -->
    <footer class="page-footer">
        <p><em>Chemical Thinking: The Grammar of Reality</em></p>
        <p>DIRECTION — Version 2.0 — December 2024</p>
    </footer>

    <!-- SCRIPTS -->
    <script>
        // ============================================
        // SCROLL PROGRESS
        // ============================================
        const progress = document.getElementById('progress');
        window.addEventListener('scroll', () => {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            progress.style.width = (scrollTop / docHeight * 100) + '%';
        });

        // ============================================
        // SECTION VISIBILITY
        // ============================================
        const sections = document.querySelectorAll('section');
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, { threshold: 0.1 });

        sections.forEach(s => observer.observe(s));

        // ============================================
        // DEFINITION POPUPS
        // ============================================
        document.querySelectorAll('.def-popup').forEach(el => {
            const definition = el.dataset.definition;
            const tooltip = el.querySelector('.def-tooltip');
            if (tooltip && definition) {
                tooltip.textContent = definition;
            }
        });

        // ============================================
        // SCROLL HINT FADE
        // ============================================
        const scrollHint = document.querySelector('.scroll-hint');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 100) {
                scrollHint.style.opacity = '0';
            } else {
                scrollHint.style.opacity = '1';
            }
        });

        // ============================================
        // ISOTROPIC VOID VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('isotropic-void-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 350;
            }
            resize();
            window.addEventListener('resize', resize);

            const gridSpacing = 40;
            const particles = [];
            const numParticles = 80;

            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: 2 + Math.random() * 3,
                    alpha: 0.5 + Math.random() * 0.5
                });
            }

            let time = 0;

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#0a0d12';
                ctx.fillRect(0, 0, w, h);

                const breathe = 0.15 + Math.sin(time * 0.5) * 0.05;

                // Grid - brighter
                ctx.strokeStyle = `rgba(100, 180, 255, ${breathe})`;
                ctx.lineWidth = 1;

                for (let x = gridSpacing; x < w; x += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                for (let y = gridSpacing; y < h; y += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }

                // Grid dots - brighter
                ctx.fillStyle = `rgba(100, 180, 255, ${breathe * 2.5})`;
                for (let x = gridSpacing; x < w; x += gridSpacing) {
                    for (let y = gridSpacing; y < h; y += gridSpacing) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Particles - brighter, more visible
                particles.forEach(p => {
                    p.vx += (Math.random() - 0.5) * 0.1;
                    p.vy += (Math.random() - 0.5) * 0.1;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0) p.x += w;
                    if (p.x > w) p.x -= w;
                    if (p.y < 0) p.y += h;
                    if (p.y > h) p.y -= h;

                    ctx.fillStyle = `rgba(200, 210, 230, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(150, 160, 180, 0.8)';
                ctx.textAlign = 'center';
                ctx.fillText('every point ≡ every other point', w/2, h - 20);

                time += 0.016;
                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // THE BREAKING VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('breaking-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 350;
            }
            resize();
            window.addEventListener('resize', resize);

            const gridSpacing = 40;
            let mass = null;
            let transitionProgress = 0;
            let time = 0;

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                mass = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                transitionProgress = 0;
            });

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#0a0d12';
                ctx.fillRect(0, 0, w, h);

                if (mass && transitionProgress < 1) transitionProgress += 0.025;
                const t = mass ? Math.min(transitionProgress, 1) : 0;
                const easedT = t * t * (3 - 2 * t);

                const breathe = 0.15 + Math.sin(time * 0.5) * 0.05;
                ctx.strokeStyle = `rgba(100, 180, 255, ${breathe})`;
                ctx.lineWidth = 1;

                for (let x = gridSpacing; x < w; x += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                for (let y = gridSpacing; y < h; y += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }

                ctx.fillStyle = `rgba(100, 180, 255, ${breathe * 2})`;
                for (let x = gridSpacing; x < w; x += gridSpacing) {
                    for (let y = gridSpacing; y < h; y += gridSpacing) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                if (mass && easedT > 0) {
                    const pulse = 1 + Math.sin(time * 3) * 0.15;
                    const massRadius = 20 * pulse * easedT;

                    // Bright glow
                    const gradient = ctx.createRadialGradient(mass.x, mass.y, 0, mass.x, mass.y, 120);
                    gradient.addColorStop(0, `rgba(255, 150, 100, ${0.6 * easedT})`);
                    gradient.addColorStop(0.5, `rgba(255, 100, 80, ${0.2 * easedT})`);
                    gradient.addColorStop(1, 'rgba(255, 80, 60, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(mass.x, mass.y, 120, 0, Math.PI * 2);
                    ctx.fill();

                    // Mass - bright orange
                    ctx.fillStyle = `rgba(255, 150, 80, ${easedT})`;
                    ctx.beginPath();
                    ctx.arc(mass.x, mass.y, massRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = `rgba(255, 200, 150, ${easedT})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Bright arrows
                    for (let x = gridSpacing; x < w; x += gridSpacing) {
                        for (let y = gridSpacing; y < h; y += gridSpacing) {
                            const dx = mass.x - x;
                            const dy = mass.y - y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 30) continue;

                            const nx = dx / dist;
                            const ny = dy / dist;
                            const strength = Math.min(25, 500 / dist) * easedT;
                            const endX = x + nx * strength;
                            const endY = y + ny * strength;

                            ctx.strokeStyle = `rgba(255, 180, 120, ${0.9 * easedT * Math.min(1, strength / 15)})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();

                            const headLen = 6;
                            const angle = Math.atan2(ny, nx);
                            ctx.beginPath();
                            ctx.moveTo(endX, endY);
                            ctx.lineTo(endX - headLen * Math.cos(angle - 0.5), endY - headLen * Math.sin(angle - 0.5));
                            ctx.moveTo(endX, endY);
                            ctx.lineTo(endX - headLen * Math.cos(angle + 0.5), endY - headLen * Math.sin(angle + 0.5));
                            ctx.stroke();
                        }
                    }

                    ctx.font = 'bold 14px "JetBrains Mono", monospace';
                    ctx.fillStyle = `rgba(255, 180, 120, ${easedT})`;
                    ctx.textAlign = 'center';
                    ctx.fillText('ONE MASS → DIRECTION EVERYWHERE', w/2, h - 20);
                } else {
                    ctx.font = 'bold 13px "JetBrains Mono", monospace';
                    ctx.fillStyle = 'rgba(150, 180, 220, 0.8)';
                    ctx.textAlign = 'center';
                    ctx.fillText('⬤ click anywhere to break the symmetry', w/2, h - 20);
                }

                time += 0.016;
                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // SPHERE → CONE MORPH VISUALIZATION (SIDE VIEW)
        // ============================================
        (function() {
            const canvas = document.getElementById('sphere-cone-canvas');
            const slider = document.getElementById('morph-slider');
            if (!canvas || !slider) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 350;
            }
            resize();
            window.addEventListener('resize', resize);

            let morphT = 0;
            let rotationAngle = 0;

            slider.addEventListener('input', () => {
                morphT = slider.value / 100;
            });

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                rotationAngle += 0.012;

                const centerX = w / 2;
                const centerY = h / 2 + 20;
                const radius = 100;

                // 3D to 2D projection (side view with slight tilt)
                function project(x, y, z) {
                    const cosR = Math.cos(rotationAngle);
                    const sinR = Math.sin(rotationAngle);
                    // Rotate around Y axis
                    const rx = x * cosR - z * sinR;
                    const rz = x * sinR + z * cosR;
                    // Slight perspective
                    const scale = 1 / (1 - rz * 0.001);
                    return {
                        x: centerX + rx * scale,
                        y: centerY - y * scale,
                        z: rz
                    };
                }

                // Morph function: sphere point to cone point
                function morphPoint(theta, phi, t) {
                    // Sphere: standard spherical coordinates
                    const sphereX = radius * Math.sin(phi) * Math.cos(theta);
                    const sphereY = radius * Math.cos(phi);
                    const sphereZ = radius * Math.sin(phi) * Math.sin(theta);

                    // Cone: tip at top, base at bottom
                    // phi=0 is top (tip), phi=PI is bottom (wide base)
                    const coneHeight = radius * 1.8;
                    const coneRadius = (phi / Math.PI) * radius * 0.9;
                    const coneY = radius - (phi / Math.PI) * coneHeight;
                    const coneX = coneRadius * Math.cos(theta);
                    const coneZ = coneRadius * Math.sin(theta);

                    return {
                        x: sphereX * (1 - t) + coneX * t,
                        y: sphereY * (1 - t) + coneY * t,
                        z: sphereZ * (1 - t) + coneZ * t
                    };
                }

                // Draw wireframe
                ctx.strokeStyle = `rgba(200, 140, 255, ${0.6 + morphT * 0.3})`;
                ctx.lineWidth = 1.5;

                // Latitude circles (parallels)
                for (let i = 1; i <= 8; i++) {
                    const phi = (i / 9) * Math.PI;
                    ctx.beginPath();
                    let started = false;
                    for (let j = 0; j <= 48; j++) {
                        const theta = (j / 48) * Math.PI * 2;
                        const pt = morphPoint(theta, phi, morphT);
                        const p = project(pt.x, pt.y, pt.z);
                        if (!started) {
                            ctx.moveTo(p.x, p.y);
                            started = true;
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    ctx.stroke();
                }

                // Longitude lines (meridians)
                for (let j = 0; j < 12; j++) {
                    const theta = (j / 12) * Math.PI * 2;
                    ctx.beginPath();
                    for (let i = 0; i <= 24; i++) {
                        const phi = (i / 24) * Math.PI;
                        const pt = morphPoint(theta, phi, morphT);
                        const p = project(pt.x, pt.y, pt.z);
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                }

                // Highlight the tip when cone forms
                if (morphT > 0.3) {
                    const tipPt = morphPoint(0, 0, morphT);
                    const tipP = project(tipPt.x, tipPt.y, tipPt.z);
                    const tipAlpha = (morphT - 0.3) / 0.7;

                    // Glowing tip
                    ctx.fillStyle = `rgba(255, 200, 100, ${tipAlpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(tipP.x, tipP.y, 6 + tipAlpha * 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Direction arrow from tip
                    if (morphT > 0.5) {
                        const arrowAlpha = (morphT - 0.5) / 0.5;
                        const arrowLen = 60 * arrowAlpha;

                        ctx.strokeStyle = `rgba(255, 160, 100, ${arrowAlpha * 0.95})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(tipP.x, tipP.y);
                        ctx.lineTo(tipP.x, tipP.y - arrowLen);
                        ctx.stroke();

                        // Arrowhead
                        ctx.fillStyle = `rgba(255, 160, 100, ${arrowAlpha * 0.95})`;
                        ctx.beginPath();
                        ctx.moveTo(tipP.x, tipP.y - arrowLen);
                        ctx.lineTo(tipP.x - 10, tipP.y - arrowLen + 15);
                        ctx.lineTo(tipP.x + 10, tipP.y - arrowLen + 15);
                        ctx.closePath();
                        ctx.fill();

                        // Label
                        ctx.font = 'bold 14px "JetBrains Mono", monospace';
                        ctx.fillStyle = `rgba(255, 180, 130, ${arrowAlpha * 0.95})`;
                        ctx.textAlign = 'center';
                        ctx.fillText('DIRECTION', tipP.x, tipP.y - arrowLen - 12);
                    }
                }

                // Status text
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';

                if (morphT < 0.25) {
                    ctx.fillStyle = 'rgba(200, 160, 255, 0.95)';
                    ctx.fillText('SPHERE: every direction equivalent (no preferred axis)', centerX, h - 18);
                } else if (morphT > 0.75) {
                    ctx.fillStyle = 'rgba(255, 180, 130, 0.95)';
                    ctx.fillText('CONE: one direction is special → IT POINTS', centerX, h - 18);
                } else {
                    ctx.fillStyle = 'rgba(220, 200, 255, 0.8)';
                    ctx.fillText('symmetry breaking → direction emerges...', centerX, h - 18);
                }

                // Morph percentage
                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(150, 150, 180, 0.7)';
                ctx.textAlign = 'left';
                ctx.fillText(`${Math.round(morphT * 100)}%`, 15, 25);

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // AMOEBA UR-DIRECTION VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('amoeba-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 400;
            }
            resize();
            window.addEventListener('resize', resize);

            // Amoeba state
            const amoeba = {
                x: 350, y: 200,
                vx: 0, vy: 0,
                membranePoints: [],
                numPoints: 24,
                baseRadius: 35
            };

            // Initialize membrane
            for (let i = 0; i < amoeba.numPoints; i++) {
                const angle = (i / amoeba.numPoints) * Math.PI * 2;
                amoeba.membranePoints.push({
                    angle: angle,
                    radius: amoeba.baseRadius,
                    targetRadius: amoeba.baseRadius,
                    phase: Math.random() * Math.PI * 2
                });
            }

            // Nutrient and toxin
            let nutrient = { x: 550, y: 150 };
            let toxin = { x: 150, y: 300 };

            // Dragging
            let dragging = null;
            let dragOffset = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                // Check nutrient
                if (Math.hypot(mx - nutrient.x, my - nutrient.y) < 25) {
                    dragging = 'nutrient';
                    dragOffset = { x: nutrient.x - mx, y: nutrient.y - my };
                }
                // Check toxin
                else if (Math.hypot(mx - toxin.x, my - toxin.y) < 25) {
                    dragging = 'toxin';
                    dragOffset = { x: toxin.x - mx, y: toxin.y - my };
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                if (dragging === 'nutrient') {
                    nutrient.x = mx + dragOffset.x;
                    nutrient.y = my + dragOffset.y;
                } else if (dragging === 'toxin') {
                    toxin.x = mx + dragOffset.x;
                    toxin.y = my + dragOffset.y;
                }
            });

            canvas.addEventListener('mouseup', () => { dragging = null; });
            canvas.addEventListener('mouseleave', () => { dragging = null; });

            let time = 0;

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                // Background - darker petri dish
                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                // Petri dish edge - brighter
                ctx.strokeStyle = 'rgba(120, 180, 255, 0.25)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(w/2, h/2, Math.min(w, h) * 0.45, 0, Math.PI * 2);
                ctx.stroke();

                // Environment particles - brighter
                ctx.fillStyle = 'rgba(180, 200, 220, 0.3)';
                for (let i = 0; i < 40; i++) {
                    const px = (Math.sin(time * 0.3 + i * 1.7) * 0.5 + 0.5) * w;
                    const py = (Math.cos(time * 0.2 + i * 2.3) * 0.5 + 0.5) * h;
                    ctx.beginPath();
                    ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Calculate forces on amoeba
                const ndx = nutrient.x - amoeba.x;
                const ndy = nutrient.y - amoeba.y;
                const ndist = Math.sqrt(ndx * ndx + ndy * ndy);

                const tdx = toxin.x - amoeba.x;
                const tdy = toxin.y - amoeba.y;
                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Chemotaxis: toward nutrient, away from toxin
                let fx = 0, fy = 0;
                if (ndist > 50) {
                    fx += (ndx / ndist) * 0.015;
                    fy += (ndy / ndist) * 0.015;
                }
                // Toxin repulsion - always active, stronger when close
                const repelStrength = 0.02 + Math.min(0.2, 300 / (tdist * tdist + 50));
                fx -= (tdx / (tdist + 1)) * repelStrength;
                fy -= (tdy / (tdist + 1)) * repelStrength;

                // Apply forces
                amoeba.vx += fx;
                amoeba.vy += fy;
                amoeba.vx *= 0.95;
                amoeba.vy *= 0.95;

                // Speed limit
                const speed = Math.sqrt(amoeba.vx * amoeba.vx + amoeba.vy * amoeba.vy);
                if (speed > 1.5) {
                    amoeba.vx = (amoeba.vx / speed) * 1.5;
                    amoeba.vy = (amoeba.vy / speed) * 1.5;
                }

                amoeba.x += amoeba.vx;
                amoeba.y += amoeba.vy;

                // Boundary
                amoeba.x = Math.max(50, Math.min(w - 50, amoeba.x));
                amoeba.y = Math.max(50, Math.min(h - 50, amoeba.y));

                // Update membrane - pseudopod toward nutrient
                const moveAngle = Math.atan2(amoeba.vy, amoeba.vx);
                amoeba.membranePoints.forEach((p, i) => {
                    const angleDiff = Math.abs(((p.angle - moveAngle + Math.PI) % (Math.PI * 2)) - Math.PI);
                    const extension = speed > 0.2 ? Math.max(0, 1 - angleDiff / 1.2) * 12 : 0;
                    p.targetRadius = amoeba.baseRadius + extension + Math.sin(time * 2 + p.phase) * 3;
                    p.radius += (p.targetRadius - p.radius) * 0.1;
                });

                // Draw slime trail
                ctx.fillStyle = 'rgba(126, 231, 135, 0.03)';
                ctx.beginPath();
                ctx.arc(amoeba.x - amoeba.vx * 5, amoeba.y - amoeba.vy * 5, 25, 0, Math.PI * 2);
                ctx.fill();

                // Draw amoeba membrane
                ctx.beginPath();
                const pts = amoeba.membranePoints;
                for (let i = 0; i <= pts.length; i++) {
                    const p = pts[i % pts.length];
                    const x = amoeba.x + Math.cos(p.angle) * p.radius;
                    const y = amoeba.y + Math.sin(p.angle) * p.radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else {
                        const prev = pts[(i - 1 + pts.length) % pts.length];
                        const px = amoeba.x + Math.cos(prev.angle) * prev.radius;
                        const py = amoeba.y + Math.sin(prev.angle) * prev.radius;
                        const cpx = (px + x) / 2 + (Math.random() - 0.5) * 2;
                        const cpy = (py + y) / 2 + (Math.random() - 0.5) * 2;
                        ctx.quadraticCurveTo(cpx, cpy, x, y);
                    }
                }
                ctx.closePath();

                const amoebaGrad = ctx.createRadialGradient(amoeba.x, amoeba.y, 0, amoeba.x, amoeba.y, 50);
                amoebaGrad.addColorStop(0, 'rgba(100, 255, 150, 0.7)');
                amoebaGrad.addColorStop(0.5, 'rgba(80, 230, 120, 0.45)');
                amoebaGrad.addColorStop(1, 'rgba(60, 200, 100, 0.25)');
                ctx.fillStyle = amoebaGrad;
                ctx.fill();
                ctx.strokeStyle = 'rgba(140, 255, 170, 0.85)';
                ctx.lineWidth = 2.5;
                ctx.stroke();

                // Nucleus - brighter
                ctx.fillStyle = 'rgba(150, 255, 180, 0.7)';
                ctx.beginPath();
                ctx.arc(amoeba.x + Math.sin(time) * 3, amoeba.y + Math.cos(time * 0.7) * 3, 10, 0, Math.PI * 2);
                ctx.fill();

                // Draw nutrient (bright green, pulsing)
                const nPulse = 1 + Math.sin(time * 3) * 0.2;
                ctx.fillStyle = 'rgba(100, 255, 140, 0.4)';
                ctx.beginPath();
                ctx.arc(nutrient.x, nutrient.y, 35 * nPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#50FF90';
                ctx.beginPath();
                ctx.arc(nutrient.x, nutrient.y, 18 * nPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(150, 255, 200, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.font = 'bold 16px "Inter", sans-serif';
                ctx.fillStyle = '#0a0d12';
                ctx.textAlign = 'center';
                ctx.fillText('N', nutrient.x, nutrient.y + 6);

                // Draw toxin (bright red, spiky)
                ctx.fillStyle = 'rgba(255, 100, 80, 0.4)';
                ctx.beginPath();
                ctx.arc(toxin.x, toxin.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FF6050';
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const a = (i / 8) * Math.PI * 2 + time * 0.5;
                    const r = i % 2 === 0 ? 22 : 12;
                    const x = toxin.x + Math.cos(a) * r;
                    const y = toxin.y + Math.sin(a) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 150, 130, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.font = 'bold 14px "Inter", sans-serif';
                ctx.fillStyle = '#0a0d12';
                ctx.textAlign = 'center';
                ctx.fillText('T', toxin.x, toxin.y + 5);

                // Direction arrows - BRIGHTER
                // Toward nutrient
                if (ndist > 60) {
                    const arrowX = amoeba.x + (ndx / ndist) * 60;
                    const arrowY = amoeba.y + (ndy / ndist) * 60;
                    ctx.strokeStyle = 'rgba(100, 255, 150, 0.9)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(amoeba.x + (ndx / ndist) * 48, amoeba.y + (ndy / ndist) * 48);
                    ctx.lineTo(arrowX, arrowY);
                    ctx.stroke();
                    const ang = Math.atan2(ndy, ndx);
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - 10 * Math.cos(ang - 0.4), arrowY - 10 * Math.sin(ang - 0.4));
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - 10 * Math.cos(ang + 0.4), arrowY - 10 * Math.sin(ang + 0.4));
                    ctx.stroke();
                }

                // Away from toxin
                if (tdist < 250) {
                    const awayX = amoeba.x - (tdx / tdist) * 60;
                    const awayY = amoeba.y - (tdy / tdist) * 60;
                    ctx.strokeStyle = 'rgba(255, 120, 100, 0.9)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(amoeba.x - (tdx / tdist) * 48, amoeba.y - (tdy / tdist) * 48);
                    ctx.lineTo(awayX, awayY);
                    ctx.stroke();
                    const ang = Math.atan2(-tdy, -tdx);
                    ctx.beginPath();
                    ctx.moveTo(awayX, awayY);
                    ctx.lineTo(awayX - 10 * Math.cos(ang - 0.4), awayY - 10 * Math.sin(ang - 0.4));
                    ctx.moveTo(awayX, awayY);
                    ctx.lineTo(awayX - 10 * Math.cos(ang + 0.4), awayY - 10 * Math.sin(ang + 0.4));
                    ctx.stroke();
                }

                // Labels - brighter
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(100, 255, 150, 0.95)';
                ctx.fillText('→ TOWARD', 20, 30);
                ctx.fillStyle = 'rgba(255, 120, 100, 0.95)';
                ctx.fillText('← AWAY', 20, 52);

                time += 0.016;
                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // BODY DIRECTIONS VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('body-directions-canvas');
            const slider = document.getElementById('body-rotation');
            if (!canvas || !slider) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 400;
            }
            resize();
            window.addEventListener('resize', resize);

            let bodyAngle = 0;

            slider.addEventListener('input', () => {
                bodyAngle = (slider.value / 180) * Math.PI;
            });

            function drawArrow(x1, y1, x2, y2, color, label, labelPos) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const headLen = 12;
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - headLen * Math.cos(angle - 0.4), y2 - headLen * Math.sin(angle - 0.4));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - headLen * Math.cos(angle + 0.4), y2 - headLen * Math.sin(angle + 0.4));
                ctx.stroke();

                // Label
                ctx.font = '11px "JetBrains Mono", monospace';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.fillText(label, labelPos.x, labelPos.y);
            }

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                const centerX = w / 2;
                const centerY = h / 2;

                // Draw floor grid - brighter
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = -5; i <= 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(centerX + i * 40, centerY - 150);
                    ctx.lineTo(centerX + i * 40, centerY + 150);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX - 200, centerY + i * 30);
                    ctx.lineTo(centerX + 200, centerY + i * 30);
                    ctx.stroke();
                }

                // Draw body - brighter
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(bodyAngle);

                // Body ellipse - brighter purple
                ctx.fillStyle = 'rgba(180, 120, 255, 0.5)';
                ctx.strokeStyle = 'rgba(200, 150, 255, 0.85)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(0, 0, 38, 48, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Face - brighter orange
                ctx.fillStyle = 'rgba(255, 160, 120, 0.95)';
                ctx.beginPath();
                ctx.arc(0, -38, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 200, 180, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Eyes
                ctx.fillStyle = '#080a0e';
                ctx.beginPath();
                ctx.arc(-7, -40, 4, 0, Math.PI * 2);
                ctx.arc(7, -40, 4, 0, Math.PI * 2);
                ctx.fill();

                // Forward arrow - BRIGHT GREEN
                const arrowLen = 90;
                drawArrow(0, -55, 0, -55 - arrowLen, 'rgba(80, 255, 140, 0.95)', '', {x: 0, y: 0});
                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.font = 'bold 14px "JetBrains Mono", monospace';
                ctx.save();
                ctx.translate(0, -55 - arrowLen - 18);
                ctx.rotate(-bodyAngle);
                ctx.fillText('FORWARD', 0, 0);
                ctx.restore();

                // Backward arrow
                drawArrow(0, 55, 0, 55 + arrowLen * 0.6, 'rgba(80, 255, 140, 0.65)', '', {x: 0, y: 0});
                ctx.fillStyle = 'rgba(80, 255, 140, 0.65)';
                ctx.save();
                ctx.translate(0, 55 + arrowLen * 0.6 + 18);
                ctx.rotate(-bodyAngle);
                ctx.fillText('BACK', 0, 0);
                ctx.restore();

                // Left arrow - BRIGHT CYAN
                drawArrow(-45, 0, -45 - arrowLen * 0.6, 0, 'rgba(80, 200, 255, 0.95)', '', {x: 0, y: 0});
                ctx.fillStyle = 'rgba(80, 200, 255, 0.95)';
                ctx.save();
                ctx.translate(-45 - arrowLen * 0.6 - 28, 0);
                ctx.rotate(-bodyAngle);
                ctx.fillText('LEFT', 0, 5);
                ctx.restore();

                // Right arrow
                drawArrow(45, 0, 45 + arrowLen * 0.6, 0, 'rgba(80, 200, 255, 0.95)', '', {x: 0, y: 0});
                ctx.fillStyle = 'rgba(80, 200, 255, 0.95)';
                ctx.save();
                ctx.translate(45 + arrowLen * 0.6 + 28, 0);
                ctx.rotate(-bodyAngle);
                ctx.fillText('RIGHT', 0, 5);
                ctx.restore();

                ctx.restore();

                // Up/Down arrows - BRIGHT ORANGE
                const upDownX = w - 85;
                ctx.strokeStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.lineWidth = 4;

                // Up arrow
                ctx.beginPath();
                ctx.moveTo(upDownX, centerY);
                ctx.lineTo(upDownX, centerY - 90);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(upDownX, centerY - 90);
                ctx.lineTo(upDownX - 12, centerY - 75);
                ctx.moveTo(upDownX, centerY - 90);
                ctx.lineTo(upDownX + 12, centerY - 75);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 180, 130, 0.95)';
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('UP', upDownX, centerY - 100);
                ctx.font = '11px "JetBrains Mono", monospace';
                ctx.fillText('(gravity)', upDownX, centerY - 115);

                // Down arrow
                ctx.strokeStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.beginPath();
                ctx.moveTo(upDownX, centerY);
                ctx.lineTo(upDownX, centerY + 90);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(upDownX, centerY + 90);
                ctx.lineTo(upDownX - 12, centerY + 75);
                ctx.moveTo(upDownX, centerY + 90);
                ctx.lineTo(upDownX + 12, centerY + 75);
                ctx.stroke();
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.fillText('DOWN', upDownX, centerY + 108);

                // Earth symbol - brighter
                ctx.fillStyle = 'rgba(255, 160, 100, 0.5)';
                ctx.beginPath();
                ctx.arc(upDownX, centerY + 140, 24, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(255, 200, 160, 0.9)';
                ctx.font = '20px serif';
                ctx.fillText('⊕', upDownX, centerY + 147);

                // Annotations - BRIGHTER
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.fillText('BODY-RELATIVE', 25, 28);
                ctx.font = '11px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(80, 255, 140, 0.7)';
                ctx.fillText('(rotates with you)', 25, 46);
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 180, 130, 0.95)';
                ctx.textAlign = 'right';
                ctx.fillText('GRAVITY-FIXED', w - 25, 28);
                ctx.font = '11px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 180, 130, 0.7)';
                ctx.fillText('(always the same)', w - 25, 46);

                // Center point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fill();

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // CIRCLE OF DIRECTIONS VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('circle-directions-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 350;
            }
            resize();
            window.addEventListener('resize', resize);

            let angle = Math.PI / 4; // Start at 45°
            let isDragging = false;

            function getMouseAngle(e) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left - canvas.width / 2;
                const my = e.clientY - rect.top - canvas.height / 2;
                return Math.atan2(-my, mx); // Negative y for screen coords
            }

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                angle = getMouseAngle(e);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    angle = getMouseAngle(e);
                }
            });

            canvas.addEventListener('mouseup', () => { isDragging = false; });
            canvas.addEventListener('mouseleave', () => { isDragging = false; });

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                const centerX = w / 2;
                const centerY = h / 2;
                const radius = 125;

                // Draw circle - BRIGHTER
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw tick marks and labels
                const directions = [
                    { angle: 0, label: '0°' },
                    { angle: Math.PI / 2, label: '90°' },
                    { angle: Math.PI, label: '180°' },
                    { angle: 3 * Math.PI / 2, label: '270°' }
                ];

                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                directions.forEach(d => {
                    const x1 = centerX + Math.cos(d.angle) * (radius - 12);
                    const y1 = centerY - Math.sin(d.angle) * (radius - 12);
                    const x2 = centerX + Math.cos(d.angle) * (radius + 12);
                    const y2 = centerY - Math.sin(d.angle) * (radius + 12);

                    ctx.strokeStyle = 'rgba(100, 180, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();

                    const labelX = centerX + Math.cos(d.angle) * (radius + 32);
                    const labelY = centerY - Math.sin(d.angle) * (radius + 32);
                    ctx.fillStyle = 'rgba(120, 200, 255, 0.9)';
                    ctx.textAlign = 'center';
                    ctx.fillText(d.label, labelX, labelY + 5);
                });

                // Draw arc showing angle - BRIGHTER GREEN
                ctx.strokeStyle = 'rgba(80, 255, 140, 0.5)';
                ctx.lineWidth = 25;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 45, 0, -angle, angle < 0);
                ctx.stroke();

                // Draw direction arrow - BRIGHT ORANGE
                const arrowX = centerX + Math.cos(angle) * radius;
                const arrowY = centerY - Math.sin(angle) * radius;

                ctx.strokeStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(arrowX, arrowY);
                ctx.stroke();

                // Arrowhead
                const headLen = 18;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX - headLen * Math.cos(angle - 0.4), arrowY + headLen * Math.sin(angle - 0.4));
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX - headLen * Math.cos(angle + 0.4), arrowY + headLen * Math.sin(angle + 0.4));
                ctx.stroke();

                // Draw point on circle - BRIGHT
                ctx.fillStyle = '#FF9060';
                ctx.beginPath();
                ctx.arc(arrowX, arrowY, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 200, 160, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Center point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fill();

                // Angle display - BRIGHTER
                let degrees = (angle * 180 / Math.PI);
                if (degrees < 0) degrees += 360;
                degrees = degrees.toFixed(1);

                ctx.font = 'bold 28px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText(`θ = ${degrees}°`, centerX, centerY + radius + 55);

                // Coordinates - BRIGHTER
                const cosVal = Math.cos(angle).toFixed(3);
                const sinVal = Math.sin(angle).toFixed(3);
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(180, 200, 220, 0.9)';
                ctx.fillText(`(cos θ, sin θ) = (${cosVal}, ${sinVal})`, centerX, centerY + radius + 80);

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // COMPARING DIRECTIONS VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('comparing-directions-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 350;
            }
            resize();
            window.addEventListener('resize', resize);

            let angle1 = Math.PI / 6;  // 30°
            let angle2 = Math.PI * 2 / 3; // 120°
            let dragging = null;

            function getMouseAngle(e) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left - canvas.width / 2;
                const my = e.clientY - rect.top - canvas.height / 2;
                return Math.atan2(-my, mx);
            }

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left - canvas.width / 2;
                const my = e.clientY - rect.top - canvas.height / 2;
                const r = 100;

                // Check which arrow tip is closer
                const d1 = Math.hypot(mx - Math.cos(angle1) * r, my + Math.sin(angle1) * r);
                const d2 = Math.hypot(mx - Math.cos(angle2) * r, my + Math.sin(angle2) * r);

                if (d1 < 30) dragging = 1;
                else if (d2 < 30) dragging = 2;
                else dragging = null;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (dragging === 1) angle1 = getMouseAngle(e);
                else if (dragging === 2) angle2 = getMouseAngle(e);
            });

            canvas.addEventListener('mouseup', () => { dragging = null; });
            canvas.addEventListener('mouseleave', () => { dragging = null; });

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                const centerX = w / 2;
                const centerY = h / 2 - 25;
                const arrowLen = 110;

                // Reference circle - BRIGHTER
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, arrowLen, 0, Math.PI * 2);
                ctx.stroke();

                // Draw arc between arrows - BRIGHTER PURPLE
                let angleBetween = angle2 - angle1;
                if (angleBetween < 0) angleBetween += Math.PI * 2;
                if (angleBetween > Math.PI) angleBetween = Math.PI * 2 - angleBetween;

                ctx.strokeStyle = 'rgba(200, 140, 255, 0.6)';
                ctx.lineWidth = 12;
                ctx.beginPath();
                const startAngle = Math.min(angle1, angle2);
                const endAngle = Math.max(angle1, angle2);
                ctx.arc(centerX, centerY, 45, -endAngle, -startAngle);
                ctx.stroke();

                // Arrow 1 - BRIGHT ORANGE
                const x1 = centerX + Math.cos(angle1) * arrowLen;
                const y1 = centerY - Math.sin(angle1) * arrowLen;
                ctx.strokeStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x1, y1);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x1 - 14 * Math.cos(angle1 - 0.4), y1 + 14 * Math.sin(angle1 - 0.4));
                ctx.moveTo(x1, y1);
                ctx.lineTo(x1 - 14 * Math.cos(angle1 + 0.4), y1 + 14 * Math.sin(angle1 + 0.4));
                ctx.stroke();
                ctx.fillStyle = '#FF9060';
                ctx.beginPath();
                ctx.arc(x1, y1, 9, 0, Math.PI * 2);
                ctx.fill();

                // Arrow 2 - BRIGHT GREEN
                const x2 = centerX + Math.cos(angle2) * arrowLen;
                const y2 = centerY - Math.sin(angle2) * arrowLen;
                ctx.strokeStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - 14 * Math.cos(angle2 - 0.4), y2 + 14 * Math.sin(angle2 - 0.4));
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - 14 * Math.cos(angle2 + 0.4), y2 + 14 * Math.sin(angle2 + 0.4));
                ctx.stroke();
                ctx.fillStyle = '#60FF90';
                ctx.beginPath();
                ctx.arc(x2, y2, 9, 0, Math.PI * 2);
                ctx.fill();

                // Center
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
                ctx.fill();

                // Angle display - BRIGHTER
                const degreesBetween = (angleBetween * 180 / Math.PI).toFixed(1);
                ctx.font = 'bold 26px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(200, 160, 255, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText(`Δθ = ${degreesBetween}°`, centerX, centerY + arrowLen + 48);

                // Dot product preview - BRIGHTER
                const dotProduct = Math.cos(angleBetween);
                ctx.font = 'bold 15px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(180, 200, 220, 0.9)';
                ctx.fillText(`cos(Δθ) = ${dotProduct.toFixed(3)}`, centerX, centerY + arrowLen + 72);

                // Alignment bar - BRIGHTER
                const barWidth = 220;
                const barX = centerX - barWidth / 2;
                const barY = centerY + arrowLen + 95;

                // Background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fillRect(barX, barY, barWidth, 14);

                // Fill based on alignment - BRIGHTER
                const fillWidth = (dotProduct + 1) / 2 * barWidth;
                const barColor = dotProduct > 0 ? 'rgba(80, 255, 140, 0.85)' : 'rgba(255, 120, 100, 0.85)';
                ctx.fillStyle = barColor;
                ctx.fillRect(barX, barY, fillWidth, 14);

                // Labels - BRIGHTER
                ctx.font = 'bold 11px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 130, 110, 0.9)';
                ctx.textAlign = 'left';
                ctx.fillText('OPPOSITE', barX, barY + 30);
                ctx.fillStyle = 'rgba(80, 255, 140, 0.9)';
                ctx.textAlign = 'right';
                ctx.fillText('ALIGNED', barX + barWidth, barY + 30);
                ctx.fillStyle = 'rgba(180, 200, 220, 0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('⊥', barX + barWidth / 2, barY + 30);

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // GRADIENT LANDSCAPE VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('gradient-landscape-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 400;
            }
            resize();
            window.addEventListener('resize', resize);

            // Height function: single smooth hill
            function height(x, y) {
                const w = canvas.width;
                const h = canvas.height;
                const cx = w * 0.5;
                const cy = h * 0.45;
                const dx = (x - cx) / (w * 0.35);
                const dy = (y - cy) / (h * 0.4);
                return Math.exp(-(dx * dx + dy * dy));
            }

            // Gradient (numerical)
            function gradient(x, y) {
                const delta = 2;
                const gx = (height(x + delta, y) - height(x - delta, y)) / (2 * delta);
                const gy = (height(x, y + delta) - height(x, y - delta)) / (2 * delta);
                return { x: gx, y: gy };
            }

            // Ball state
            let ball = null;

            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                ball = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    vx: 0,
                    vy: 0
                };
            });

            // Color palette for elevation bands (low to high)
            const colors = [
                [25, 45, 80],      // Deep blue (lowest)
                [40, 80, 120],     // Ocean blue
                [60, 130, 160],    // Light blue
                [80, 170, 140],    // Teal
                [120, 200, 120],   // Green
                [180, 210, 100],   // Yellow-green
                [230, 200, 80],    // Yellow
                [250, 160, 60],    // Orange
                [255, 100, 80],    // Coral
                [255, 80, 100]     // Pink-red (peak)
            ];

            function getColor(val) {
                const idx = Math.min(colors.length - 1, Math.floor(val * colors.length));
                const nextIdx = Math.min(colors.length - 1, idx + 1);
                const t = (val * colors.length) - idx;
                const c1 = colors[idx];
                const c2 = colors[nextIdx];
                return [
                    Math.floor(c1[0] + (c2[0] - c1[0]) * t),
                    Math.floor(c1[1] + (c2[1] - c1[1]) * t),
                    Math.floor(c1[2] + (c2[2] - c1[2]) * t)
                ];
            }

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                // Draw terrain with color bands
                const imageData = ctx.createImageData(w, h);
                for (let py = 0; py < h; py++) {
                    for (let px = 0; px < w; px++) {
                        const val = height(px, py);
                        const color = getColor(val);
                        const i = (py * w + px) * 4;
                        imageData.data[i] = color[0];
                        imageData.data[i + 1] = color[1];
                        imageData.data[i + 2] = color[2];
                        imageData.data[i + 3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);

                // Draw contour lines
                ctx.lineWidth = 1.5;
                for (let level = 0.1; level <= 0.95; level += 0.1) {
                    ctx.strokeStyle = level > 0.5 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();

                    // March around finding contour points
                    for (let px = 0; px < w; px += 3) {
                        for (let py = 0; py < h; py += 3) {
                            const v = height(px, py);
                            if (Math.abs(v - level) < 0.015) {
                                ctx.moveTo(px, py);
                                ctx.lineTo(px + 1.5, py + 1.5);
                            }
                        }
                    }
                    ctx.stroke();
                }

                // Draw gradient arrows (pointing UPHILL)
                ctx.lineWidth = 2.5;
                const spacing = 50;
                for (let gx = spacing; gx < w - spacing/2; gx += spacing) {
                    for (let gy = spacing; gy < h - spacing/2; gy += spacing) {
                        const g = gradient(gx, gy);
                        const mag = Math.sqrt(g.x * g.x + g.y * g.y);
                        if (mag < 0.001) continue;

                        const len = Math.min(25, mag * 800);
                        const nx = g.x / mag;
                        const ny = g.y / mag;

                        // Arrow color based on height
                        const hVal = height(gx, gy);
                        if (hVal > 0.85) continue; // Skip peak center

                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';

                        // Arrow shaft
                        ctx.beginPath();
                        ctx.moveTo(gx, gy);
                        ctx.lineTo(gx + nx * len, gy + ny * len);
                        ctx.stroke();

                        // Arrowhead
                        const angle = Math.atan2(ny, nx);
                        ctx.beginPath();
                        ctx.moveTo(gx + nx * len, gy + ny * len);
                        ctx.lineTo(gx + nx * len - 8 * Math.cos(angle - 0.4), gy + ny * len - 8 * Math.sin(angle - 0.4));
                        ctx.lineTo(gx + nx * len - 8 * Math.cos(angle + 0.4), gy + ny * len - 8 * Math.sin(angle + 0.4));
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw peak marker
                const peakX = w * 0.5;
                const peakY = h * 0.45;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.arc(peakX, peakY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText('PEAK', peakX, peakY - 12);

                // Update and draw ball
                if (ball) {
                    const g = gradient(ball.x, ball.y);
                    // Ball rolls DOWNHILL (opposite to gradient)
                    ball.vx -= g.x * 200;
                    ball.vy -= g.y * 200;
                    ball.vx *= 0.96;
                    ball.vy *= 0.96;

                    ball.x += ball.vx * 0.016;
                    ball.y += ball.vy * 0.016;

                    ball.x = Math.max(15, Math.min(w - 15, ball.x));
                    ball.y = Math.max(15, Math.min(h - 15, ball.y));

                    // Ball shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(ball.x + 3, ball.y + 3, 14, 10, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Ball
                    const ballGrad = ctx.createRadialGradient(ball.x - 4, ball.y - 4, 0, ball.x, ball.y, 14);
                    ballGrad.addColorStop(0, '#FFFFFF');
                    ballGrad.addColorStop(0.3, '#FFE066');
                    ballGrad.addColorStop(1, '#FF9933');
                    ctx.fillStyle = ballGrad;
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, 14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(200, 100, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Gradient arrow at ball (uphill direction)
                    const bg = gradient(ball.x, ball.y);
                    const bmag = Math.sqrt(bg.x * bg.x + bg.y * bg.y);
                    if (bmag > 0.001) {
                        const arrowLen = 45;
                        const nx = bg.x / bmag;
                        const ny = bg.y / bmag;

                        ctx.strokeStyle = 'rgba(50, 255, 120, 0.95)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(ball.x, ball.y);
                        ctx.lineTo(ball.x + nx * arrowLen, ball.y + ny * arrowLen);
                        ctx.stroke();

                        // Arrowhead
                        const angle = Math.atan2(ny, nx);
                        ctx.fillStyle = 'rgba(50, 255, 120, 0.95)';
                        ctx.beginPath();
                        ctx.moveTo(ball.x + nx * arrowLen, ball.y + ny * arrowLen);
                        ctx.lineTo(ball.x + nx * arrowLen - 12 * Math.cos(angle - 0.4), ball.y + ny * arrowLen - 12 * Math.sin(angle - 0.4));
                        ctx.lineTo(ball.x + nx * arrowLen - 12 * Math.cos(angle + 0.4), ball.y + ny * arrowLen - 12 * Math.sin(angle + 0.4));
                        ctx.closePath();
                        ctx.fill();

                        ctx.font = 'bold 13px "JetBrains Mono", monospace';
                        ctx.fillStyle = 'rgba(50, 255, 120, 0.95)';
                        ctx.textAlign = 'center';
                        ctx.fillText('∇f', ball.x + nx * arrowLen + 15, ball.y + ny * arrowLen);
                    }
                }

                // Legend
                const legendX = 15;
                const legendY = 25;
                const legendH = 100;
                const legendW = 18;

                // Draw color bar
                for (let i = 0; i < legendH; i++) {
                    const val = 1 - (i / legendH);
                    const color = getColor(val);
                    ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    ctx.fillRect(legendX, legendY + i, legendW, 1);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(legendX, legendY, legendW, legendH);

                ctx.font = 'bold 11px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.textAlign = 'left';
                ctx.fillText('HIGH', legendX + legendW + 5, legendY + 10);
                ctx.fillText('LOW', legendX + legendW + 5, legendY + legendH - 2);

                // Instructions
                if (!ball) {
                    ctx.font = 'bold 14px "JetBrains Mono", monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.textAlign = 'center';
                    ctx.fillText('click anywhere to drop a ball', w / 2, h - 18);
                } else {
                    ctx.font = 'bold 12px "JetBrains Mono", monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.textAlign = 'center';
                    ctx.fillText('ball rolls downhill · green arrow = gradient (uphill)', w / 2, h - 15);
                }

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // SPHERE OF DIRECTIONS VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('sphere-directions-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const azimuthSlider = document.getElementById('sphere-azimuth');
            const elevationSlider = document.getElementById('sphere-elevation');
            const azimuthVal = document.getElementById('sphere-azimuth-val');
            const elevationVal = document.getElementById('sphere-elevation-val');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 400;
            }
            resize();
            window.addEventListener('resize', resize);

            let viewAngleY = 0.3;  // View rotation
            let autoRotate = 0;

            function project(x, y, z) {
                // Simple 3D to 2D projection with rotation
                const cosA = Math.cos(viewAngleY + autoRotate);
                const sinA = Math.sin(viewAngleY + autoRotate);
                const rx = x * cosA - z * sinA;
                const rz = x * sinA + z * cosA;

                const scale = 120;
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const perspective = 4 / (4 + rz * 0.3);

                return {
                    x: cx + rx * scale * perspective,
                    y: cy - y * scale * perspective,
                    z: rz
                };
            }

            function draw() {
                const w = canvas.width;
                const h = canvas.height;
                autoRotate += 0.003;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                const azimuth = parseFloat(azimuthSlider.value) * Math.PI / 180;
                const elevation = parseFloat(elevationSlider.value) * Math.PI / 180;

                azimuthVal.textContent = azimuthSlider.value + '°';
                elevationVal.textContent = elevationSlider.value + '°';

                // Draw wireframe sphere
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
                ctx.lineWidth = 1;

                // Latitude circles
                for (let lat = -75; lat <= 75; lat += 30) {
                    const latRad = lat * Math.PI / 180;
                    const r = Math.cos(latRad);
                    const yLevel = Math.sin(latRad);

                    ctx.beginPath();
                    for (let lon = 0; lon <= 360; lon += 5) {
                        const lonRad = lon * Math.PI / 180;
                        const x = r * Math.cos(lonRad);
                        const z = r * Math.sin(lonRad);
                        const p = project(x, yLevel, z);

                        if (lon === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                }

                // Longitude lines
                for (let lon = 0; lon < 360; lon += 30) {
                    const lonRad = lon * Math.PI / 180;
                    ctx.beginPath();
                    for (let lat = -90; lat <= 90; lat += 5) {
                        const latRad = lat * Math.PI / 180;
                        const x = Math.cos(latRad) * Math.cos(lonRad);
                        const y = Math.sin(latRad);
                        const z = Math.cos(latRad) * Math.sin(lonRad);
                        const p = project(x, y, z);

                        if (lat === -90) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                }

                // Equator - brighter
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let lon = 0; lon <= 360; lon += 5) {
                    const lonRad = lon * Math.PI / 180;
                    const p = project(Math.cos(lonRad), 0, Math.sin(lonRad));
                    if (lon === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();

                // Draw coordinate axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;

                // X axis
                let p1 = project(-1.3, 0, 0);
                let p2 = project(1.3, 0, 0);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.font = 'bold 14px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillText('x', p2.x + 10, p2.y + 5);

                // Y axis
                p1 = project(0, -1.3, 0);
                p2 = project(0, 1.3, 0);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.fillText('y', p2.x + 5, p2.y - 5);

                // Z axis
                p1 = project(0, 0, -1.3);
                p2 = project(0, 0, 1.3);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.fillText('z', p2.x + 5, p2.y + 5);

                // Calculate direction vector from angles
                const dx = Math.cos(elevation) * Math.cos(azimuth);
                const dy = Math.sin(elevation);
                const dz = Math.cos(elevation) * Math.sin(azimuth);

                // Draw direction arrow from center to sphere surface
                const origin = project(0, 0, 0);
                const tip = project(dx * 1.15, dy * 1.15, dz * 1.15);
                const surface = project(dx, dy, dz);

                // Arrow shaft - bright orange
                ctx.strokeStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(origin.x, origin.y);
                ctx.lineTo(tip.x, tip.y);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(tip.y - origin.y, tip.x - origin.x);
                ctx.fillStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.beginPath();
                ctx.moveTo(tip.x, tip.y);
                ctx.lineTo(tip.x - 14 * Math.cos(angle - 0.4), tip.y - 14 * Math.sin(angle - 0.4));
                ctx.lineTo(tip.x - 14 * Math.cos(angle + 0.4), tip.y - 14 * Math.sin(angle + 0.4));
                ctx.closePath();
                ctx.fill();

                // Draw point on sphere surface - bright
                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.beginPath();
                ctx.arc(surface.x, surface.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Show angle arcs
                // Azimuth arc on equator
                ctx.strokeStyle = 'rgba(200, 140, 255, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let a = 0; a <= azimuth; a += 0.05) {
                    const p = project(Math.cos(a) * 0.4, 0, Math.sin(a) * 0.4);
                    if (a === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();

                // Elevation arc
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.7)';
                ctx.beginPath();
                const step = elevation > 0 ? 0.05 : -0.05;
                for (let e = 0; Math.abs(e) <= Math.abs(elevation); e += step) {
                    const px = Math.cos(e) * Math.cos(azimuth) * 0.5;
                    const py = Math.sin(e) * 0.5;
                    const pz = Math.cos(e) * Math.sin(azimuth) * 0.5;
                    const p = project(px, py, pz);
                    if (e === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();

                // Labels
                ctx.font = 'bold 14px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(200, 140, 255, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText('θ', w / 2 + 50, h / 2 + 25);

                ctx.fillStyle = 'rgba(255, 200, 100, 0.95)';
                ctx.fillText('φ', surface.x + 30, surface.y - 10);

                // Info text
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(80, 255, 140, 0.9)';
                ctx.textAlign = 'left';
                ctx.fillText(`Direction: (${dx.toFixed(2)}, ${dy.toFixed(2)}, ${dz.toFixed(2)})`, 15, 25);

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // MAGNITUDE + DIRECTION VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('magnitude-direction-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const angleSlider = document.getElementById('mag-dir-angle');
            const lengthSlider = document.getElementById('mag-dir-length');
            const angleVal = document.getElementById('mag-dir-angle-val');
            const lengthVal = document.getElementById('mag-dir-length-val');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 320;
            }
            resize();
            window.addEventListener('resize', resize);

            function drawArrow(x, y, angle, length, color, label) {
                const endX = x + Math.cos(angle) * length;
                const endY = y - Math.sin(angle) * length;

                // Shaft
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Arrowhead
                const headLen = 12;
                const headAngle = 0.4;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headLen * Math.cos(angle - headAngle), endY + headLen * Math.sin(angle - headAngle));
                ctx.lineTo(endX - headLen * Math.cos(angle + headAngle), endY + headLen * Math.sin(angle + headAngle));
                ctx.closePath();
                ctx.fill();

                // Origin dot
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Label
                if (label) {
                    ctx.font = 'bold 14px "JetBrains Mono", monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, x, y + 80);
                }
            }

            function draw() {
                const w = canvas.width;
                const h = canvas.height;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                const angle = parseFloat(angleSlider.value) * Math.PI / 180;
                const magnitude = parseFloat(lengthSlider.value);

                angleVal.textContent = angleSlider.value + '°';
                lengthVal.textContent = magnitude;

                const panelWidth = w / 3;
                const centerY = h / 2 - 20;

                // Panel dividers
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(panelWidth, 40);
                ctx.lineTo(panelWidth, h - 40);
                ctx.moveTo(panelWidth * 2, 40);
                ctx.lineTo(panelWidth * 2, h - 40);
                ctx.stroke();
                ctx.setLineDash([]);

                // Panel titles
                ctx.font = 'bold 15px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(200, 140, 255, 0.95)';
                ctx.fillText('DIRECTION ONLY', panelWidth / 2, 30);
                ctx.fillStyle = 'rgba(100, 200, 255, 0.95)';
                ctx.fillText('MAGNITUDE ONLY', panelWidth * 1.5, 30);
                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.fillText('VECTOR (BOTH)', panelWidth * 2.5, 30);

                // Panel 1: Direction only (unit vector, fixed length)
                const unitLen = 60;
                drawArrow(panelWidth / 2, centerY, angle, unitLen, 'rgba(200, 140, 255, 0.95)', '');

                // Direction circle
                ctx.strokeStyle = 'rgba(200, 140, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(panelWidth / 2, centerY, unitLen, 0, Math.PI * 2);
                ctx.stroke();

                // Angle arc
                ctx.strokeStyle = 'rgba(200, 140, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(panelWidth / 2, centerY, 25, 0, -angle, true);
                ctx.stroke();

                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(200, 140, 255, 0.95)';
                ctx.fillText(`θ = ${angleSlider.value}°`, panelWidth / 2, centerY + 95);
                ctx.fillStyle = 'rgba(180, 180, 180, 0.8)';
                ctx.fillText('|v̂| = 1 (unit)', panelWidth / 2, centerY + 115);

                // Panel 2: Magnitude only (bar)
                const barWidth = 25;
                const maxBarHeight = 100;
                const barHeight = (magnitude / 100) * maxBarHeight;
                const barX = panelWidth * 1.5 - barWidth / 2;
                const barY = centerY + 50 - barHeight;

                // Bar background
                ctx.fillStyle = 'rgba(100, 200, 255, 0.15)';
                ctx.fillRect(barX, centerY + 50 - maxBarHeight, barWidth, maxBarHeight);

                // Bar fill
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Bar outline
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.95)';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, centerY + 50 - maxBarHeight, barWidth, maxBarHeight);

                // Magnitude value
                ctx.font = 'bold 16px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(100, 200, 255, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText(magnitude.toString(), panelWidth * 1.5, centerY + 75);
                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(180, 180, 180, 0.8)';
                ctx.fillText('no direction', panelWidth * 1.5, centerY + 115);
                ctx.fillText('(scalar)', panelWidth * 1.5, centerY + 130);

                // Panel 3: Vector (both)
                drawArrow(panelWidth * 2.5, centerY, angle, magnitude, 'rgba(80, 255, 140, 0.95)', '');

                // Max length indicator circle
                ctx.strokeStyle = 'rgba(80, 255, 140, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(panelWidth * 2.5, centerY, 100, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Vector info
                const vx = Math.cos(angle) * magnitude;
                const vy = Math.sin(angle) * magnitude;
                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText(`v = (${vx.toFixed(0)}, ${vy.toFixed(0)})`, panelWidth * 2.5, centerY + 95);
                ctx.fillText(`|v| = ${magnitude}, θ = ${angleSlider.value}°`, panelWidth * 2.5, centerY + 115);

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // CAUSATION FLOW VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('causation-flow-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 350;
            }
            resize();
            window.addEventListener('resize', resize);

            let time = 0;

            // Mechanism steps
            const steps = [
                { label: 'Nucleophile', shortLabel: 'Nu⁻', color: 'rgba(100, 200, 255, 0.95)' },
                { label: 'Electrophile', shortLabel: 'E⁺', color: 'rgba(255, 160, 100, 0.95)' },
                { label: 'Transition State', shortLabel: 'TS‡', color: 'rgba(200, 140, 255, 0.95)' },
                { label: 'Product', shortLabel: 'P', color: 'rgba(80, 255, 140, 0.95)' }
            ];

            // Flowing particles along arrows
            const particles = [];
            for (let i = 0; i < 12; i++) {
                particles.push({
                    progress: Math.random(),
                    speed: 0.003 + Math.random() * 0.002,
                    segment: Math.floor(Math.random() * 3)
                });
            }

            function draw() {
                const w = canvas.width;
                const h = canvas.height;
                time += 0.016;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                // Top section: Generic Cause → Effect
                const topY = 70;
                const boxW = 100;
                const boxH = 45;
                const gap = 80;

                // Cause box
                const causeX = w / 2 - boxW - gap / 2;
                ctx.fillStyle = 'rgba(255, 160, 100, 0.15)';
                ctx.fillRect(causeX, topY, boxW, boxH);
                ctx.strokeStyle = 'rgba(255, 160, 100, 0.9)';
                ctx.lineWidth = 2;
                ctx.strokeRect(causeX, topY, boxW, boxH);

                ctx.font = 'bold 16px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.textAlign = 'center';
                ctx.fillText('CAUSE', causeX + boxW / 2, topY + boxH / 2 + 6);

                // Effect box
                const effectX = w / 2 + gap / 2;
                ctx.fillStyle = 'rgba(80, 255, 140, 0.15)';
                ctx.fillRect(effectX, topY, boxW, boxH);
                ctx.strokeStyle = 'rgba(80, 255, 140, 0.9)';
                ctx.strokeRect(effectX, topY, boxW, boxH);

                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.fillText('EFFECT', effectX + boxW / 2, topY + boxH / 2 + 6);

                // Arrow between
                const arrowY = topY + boxH / 2;
                const arrowStartX = causeX + boxW + 10;
                const arrowEndX = effectX - 10;

                // Pulsing arrow
                const pulse = 0.7 + Math.sin(time * 3) * 0.3;
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(arrowStartX, arrowY);
                ctx.lineTo(arrowEndX - 15, arrowY);
                ctx.stroke();

                // Arrowhead
                ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.beginPath();
                ctx.moveTo(arrowEndX, arrowY);
                ctx.lineTo(arrowEndX - 15, arrowY - 8);
                ctx.lineTo(arrowEndX - 15, arrowY + 8);
                ctx.closePath();
                ctx.fill();

                // Time arrow underneath
                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(180, 180, 180, 0.7)';
                ctx.fillText('time →', w / 2, topY + boxH + 25);

                // Divider
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(50, 155);
                ctx.lineTo(w - 50, 155);
                ctx.stroke();
                ctx.setLineDash([]);

                // Bottom section: Chemistry Mechanism
                ctx.font = 'bold 14px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.textAlign = 'center';
                ctx.fillText('Reaction Mechanism (SN2)', w / 2, 180);

                const mechY = 240;
                const stepSpacing = (w - 100) / (steps.length - 1);
                const startX = 50;

                // Draw step boxes
                steps.forEach((step, i) => {
                    const x = startX + i * stepSpacing;
                    const boxSize = 50;

                    // Box
                    ctx.fillStyle = step.color.replace('0.95', '0.15');
                    ctx.beginPath();
                    ctx.arc(x, mechY, boxSize / 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = step.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, mechY, boxSize / 2, 0, Math.PI * 2);
                    ctx.stroke();

                    // Short label inside
                    ctx.font = 'bold 14px "JetBrains Mono", monospace';
                    ctx.fillStyle = step.color;
                    ctx.textAlign = 'center';
                    ctx.fillText(step.shortLabel, x, mechY + 5);

                    // Full label below
                    ctx.font = 'bold 11px "JetBrains Mono", monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillText(step.label, x, mechY + 50);
                });

                // Draw arrows between steps
                for (let i = 0; i < steps.length - 1; i++) {
                    const x1 = startX + i * stepSpacing + 30;
                    const x2 = startX + (i + 1) * stepSpacing - 30;

                    // Arrow shaft
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x1, mechY);
                    ctx.lineTo(x2 - 10, mechY);
                    ctx.stroke();

                    // Arrowhead
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(x2, mechY);
                    ctx.lineTo(x2 - 12, mechY - 6);
                    ctx.lineTo(x2 - 12, mechY + 6);
                    ctx.closePath();
                    ctx.fill();
                }

                // Animate flowing particles
                particles.forEach(p => {
                    p.progress += p.speed;
                    if (p.progress > 1) {
                        p.progress = 0;
                        p.segment = (p.segment + 1) % 3;
                    }

                    const x1 = startX + p.segment * stepSpacing + 30;
                    const x2 = startX + (p.segment + 1) * stepSpacing - 30;
                    const px = x1 + (x2 - x1) * p.progress;

                    ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
                    ctx.beginPath();
                    ctx.arc(px, mechY, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Timeline arrow at bottom
                ctx.strokeStyle = 'rgba(180, 180, 180, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(30, h - 30);
                ctx.lineTo(w - 30, h - 30);
                ctx.stroke();

                // Timeline arrowhead
                ctx.fillStyle = 'rgba(180, 180, 180, 0.5)';
                ctx.beginPath();
                ctx.moveTo(w - 30, h - 30);
                ctx.lineTo(w - 45, h - 36);
                ctx.lineTo(w - 45, h - 24);
                ctx.closePath();
                ctx.fill();

                ctx.font = 'bold 12px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(180, 180, 180, 0.7)';
                ctx.textAlign = 'left';
                ctx.fillText('Reactants', 35, h - 15);
                ctx.textAlign = 'right';
                ctx.fillText('Products', w - 45, h - 15);
                ctx.textAlign = 'center';
                ctx.fillText('TIME', w / 2, h - 15);

                requestAnimationFrame(draw);
            }

            draw();
        })();

        // ============================================
        // BRIDGE ANIMATION VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('bridge-animation-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                canvas.width = Math.min(700, rect.width - 64);
                canvas.height = 380;
            }
            resize();
            window.addEventListener('resize', resize);

            let time = 0;

            const bridges = [
                { perception: '"It points somewhere"', tool: 'Vector', color: 'rgba(255, 160, 100, 0.95)' },
                { perception: '"How aligned?"', tool: 'Dot Product', color: 'rgba(100, 200, 255, 0.95)' },
                { perception: '"Perpendicular to both?"', tool: 'Cross Product', color: 'rgba(200, 140, 255, 0.95)' },
                { perception: '"Which way is steepest?"', tool: 'Gradient', color: 'rgba(80, 255, 140, 0.95)' },
                { perception: '"Describe exactly"', tool: 'Components', color: 'rgba(255, 200, 100, 0.95)' }
            ];

            // Particles flowing across bridges
            const particles = [];
            for (let i = 0; i < 20; i++) {
                particles.push({
                    bridge: Math.floor(Math.random() * bridges.length),
                    progress: Math.random(),
                    speed: 0.004 + Math.random() * 0.003
                });
            }

            function draw() {
                const w = canvas.width;
                const h = canvas.height;
                time += 0.016;

                ctx.fillStyle = '#080a0e';
                ctx.fillRect(0, 0, w, h);

                // Column headers
                ctx.font = 'bold 16px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';

                ctx.fillStyle = 'rgba(255, 160, 100, 0.95)';
                ctx.fillText('PERCEPTION', 120, 35);

                ctx.fillStyle = 'rgba(80, 255, 140, 0.95)';
                ctx.fillText('FORMAL TOOL', w - 120, 35);

                // Draw bridge
                const startY = 70;
                const rowHeight = 60;
                const leftX = 30;
                const rightX = w - 30;
                const leftBoxW = 200;
                const rightBoxW = 140;

                bridges.forEach((bridge, i) => {
                    const y = startY + i * rowHeight;

                    // Left box (perception)
                    ctx.fillStyle = bridge.color.replace('0.95', '0.1');
                    ctx.fillRect(leftX, y, leftBoxW, 40);
                    ctx.strokeStyle = bridge.color.replace('0.95', '0.5');
                    ctx.lineWidth = 2;
                    ctx.strokeRect(leftX, y, leftBoxW, 40);

                    ctx.font = 'bold 13px "JetBrains Mono", monospace';
                    ctx.fillStyle = bridge.color;
                    ctx.textAlign = 'left';
                    ctx.fillText(bridge.perception, leftX + 10, y + 26);

                    // Right box (tool)
                    ctx.fillStyle = bridge.color.replace('0.95', '0.15');
                    ctx.fillRect(rightX - rightBoxW, y, rightBoxW, 40);
                    ctx.strokeStyle = bridge.color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rightX - rightBoxW, y, rightBoxW, 40);

                    ctx.font = 'bold 14px "JetBrains Mono", monospace';
                    ctx.fillStyle = bridge.color;
                    ctx.textAlign = 'center';
                    ctx.fillText(bridge.tool, rightX - rightBoxW / 2, y + 26);

                    // Connecting line
                    const lineStartX = leftX + leftBoxW;
                    const lineEndX = rightX - rightBoxW;
                    const lineY = y + 20;

                    // Draw curved bridge line
                    const cp1x = lineStartX + (lineEndX - lineStartX) * 0.3;
                    const cp2x = lineStartX + (lineEndX - lineStartX) * 0.7;

                    ctx.strokeStyle = bridge.color.replace('0.95', '0.3');
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(lineStartX, lineY);
                    ctx.bezierCurveTo(cp1x, lineY - 15, cp2x, lineY + 15, lineEndX, lineY);
                    ctx.stroke();

                    // Arrow at end
                    ctx.fillStyle = bridge.color.replace('0.95', '0.5');
                    ctx.beginPath();
                    ctx.moveTo(lineEndX, lineY);
                    ctx.lineTo(lineEndX - 10, lineY - 5);
                    ctx.lineTo(lineEndX - 10, lineY + 5);
                    ctx.closePath();
                    ctx.fill();
                });

                // Draw flowing particles
                particles.forEach(p => {
                    p.progress += p.speed;
                    if (p.progress > 1) {
                        p.progress = 0;
                        p.bridge = Math.floor(Math.random() * bridges.length);
                    }

                    const bridge = bridges[p.bridge];
                    const y = startY + p.bridge * rowHeight + 20;
                    const lineStartX = leftX + leftBoxW;
                    const lineEndX = rightX - rightBoxW;

                    // Bezier curve position
                    const t = p.progress;
                    const cp1x = lineStartX + (lineEndX - lineStartX) * 0.3;
                    const cp2x = lineStartX + (lineEndX - lineStartX) * 0.7;
                    const cp1y = y - 15;
                    const cp2y = y + 15;

                    // Cubic bezier formula
                    const mt = 1 - t;
                    const px = mt*mt*mt*lineStartX + 3*mt*mt*t*cp1x + 3*mt*t*t*cp2x + t*t*t*lineEndX;
                    const py = mt*mt*mt*y + 3*mt*mt*t*cp1y + 3*mt*t*t*cp2y + t*t*t*y;

                    ctx.fillStyle = bridge.color;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Bottom text
                ctx.font = 'bold 13px "JetBrains Mono", monospace';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.textAlign = 'center';
                ctx.fillText('Intuition → Formalism', w / 2, h - 20);

                requestAnimationFrame(draw);
            }

            draw();
        })();
    </script>

</body>
</html>
